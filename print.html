<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Goose Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">What Is Goose?</a></li><li class="chapter-item expanded affix "><a href="requirements.html">Requirements</a></li><li class="chapter-item expanded "><a href="getting-started/overview.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/creating.html"><strong aria-hidden="true">1.1.</strong> Creating A Load test</a></li><li class="chapter-item expanded "><a href="getting-started/running.html"><strong aria-hidden="true">1.2.</strong> Running A Load Test</a></li><li class="chapter-item expanded "><a href="getting-started/runtime-options.html"><strong aria-hidden="true">1.3.</strong> Run-Time Options</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/common.html"><strong aria-hidden="true">1.3.1.</strong> Common Options</a></li><li class="chapter-item expanded "><a href="getting-started/throttle.html"><strong aria-hidden="true">1.3.2.</strong> Throttle</a></li></ol></li><li class="chapter-item expanded "><a href="getting-started/metrics.html"><strong aria-hidden="true">1.4.</strong> Metrics</a></li><li class="chapter-item expanded "><a href="getting-started/tips.html"><strong aria-hidden="true">1.5.</strong> Tips</a></li></ol></li><li class="chapter-item expanded "><a href="logging/overview.html"><strong aria-hidden="true">2.</strong> Logging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="logging/requests.html"><strong aria-hidden="true">2.1.</strong> Request Log</a></li><li class="chapter-item expanded "><a href="logging/tasks.html"><strong aria-hidden="true">2.2.</strong> Task Log</a></li><li class="chapter-item expanded "><a href="logging/errors.html"><strong aria-hidden="true">2.3.</strong> Error Log</a></li><li class="chapter-item expanded "><a href="logging/debug.html"><strong aria-hidden="true">2.4.</strong> Debug Log</a></li></ol></li><li class="chapter-item expanded "><a href="controller/overview.html"><strong aria-hidden="true">3.</strong> Controllers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="controller/telnet.html"><strong aria-hidden="true">3.1.</strong> Telnet Controller</a></li><li class="chapter-item expanded "><a href="controller/websocket.html"><strong aria-hidden="true">3.2.</strong> WebSocket Controller</a></li></ol></li><li class="chapter-item expanded "><a href="gaggle/overview.html"><strong aria-hidden="true">4.</strong> Gaggle: Distributed Load Test</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gaggle/manager.html"><strong aria-hidden="true">4.1.</strong> Manager</a></li><li class="chapter-item expanded "><a href="gaggle/worker.html"><strong aria-hidden="true">4.2.</strong> Worker</a></li><li class="chapter-item expanded "><a href="gaggle/config.html"><strong aria-hidden="true">4.3.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="gaggle/technical.html"><strong aria-hidden="true">4.4.</strong> Technical details</a></li></ol></li><li class="chapter-item expanded "><a href="coordinated-omission/overview.html"><strong aria-hidden="true">5.</strong> Coordinated Omission</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="coordinated-omission/mitigation.html"><strong aria-hidden="true">5.1.</strong> Mitigation</a></li><li class="chapter-item expanded "><a href="coordinated-omission/metrics.html"><strong aria-hidden="true">5.2.</strong> Metrics</a></li></ol></li><li class="chapter-item expanded "><a href="config/overview.html"><strong aria-hidden="true">6.</strong> Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/defaults.html"><strong aria-hidden="true">6.1.</strong> Defaults</a></li><li class="chapter-item expanded "><a href="config/scheduler.html"><strong aria-hidden="true">6.2.</strong> Scheduling Users And Tasks</a></li><li class="chapter-item expanded "><a href="config/rustls.html"><strong aria-hidden="true">6.3.</strong> RustLS</a></li></ol></li><li class="chapter-item expanded "><a href="example/overview.html"><strong aria-hidden="true">7.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="example/simple.html"><strong aria-hidden="true">7.1.</strong> Simple</a></li><li class="chapter-item expanded "><a href="example/closure.html"><strong aria-hidden="true">7.2.</strong> Closure</a></li><li class="chapter-item expanded "><a href="example/session.html"><strong aria-hidden="true">7.3.</strong> Session</a></li><li class="chapter-item expanded "><a href="example/drupal-memcache.html"><strong aria-hidden="true">7.4.</strong> Drupal Memcache</a></li><li class="chapter-item expanded "><a href="example/umami.html"><strong aria-hidden="true">7.5.</strong> Umami</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Goose Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-goose-book"><a class="header" href="#the-goose-book">The Goose Book</a></h1>
<p>Have you ever been attacked by a goose?</p>
<h2 id="what-is-goose"><a class="header" href="#what-is-goose">What Is Goose?</a></h2>
<p><a href="https://docs.rs/goose">Goose</a> is a <a href="https://www.rust-lang.org/">Rust</a> load testing tool inspired by <a href="https://locust.io/">Locust</a>. User behavior is defined with standard Rust code. Load tests are applications that have a dependency on the <a href="https://crates.io/crates/goose">Goose library</a>. Web requests are made with the <a href="https://docs.rs/reqwest">Reqwest</a> HTTP Client.</p>
<h2 id="advantages"><a class="header" href="#advantages">Advantages</a></h2>
<p>Goose generates at least 11x as much traffic as Locust per-CPU-core, with even larger gains for more complex load tests (such as those using third-party libraries to scrape form content). While Locust requires you to manage a distributed load test simply to use multiple CPU cores on a single server, Goose leverages all available CPU cores with a single process, drastically simplifying the process for running larger load tests. Ongoing improvements to the codebase continue to bring new features and faster performance. Goose scales far better than Locust, efficiently using available resources to accomplish its goal. It also supports asynchronous processes enabling many more simultaneous processes to ramp up thousands of users from a single server, easily and consistently.</p>
<p>Goose’s distributed testing design is similar to Locust’s, in that it uses a one Manager to many Workers model. However, unlike Locust, you do not need to spin up a distributed load test to leverage all available cores on a single server, as a single Goose process will fully leverage all available cores. Goose distributed load tests scale near-perfectly as once started each Worker performs its load test without any direction from the Manager, and the Manager simply collects statistics from all the Workers for final reporting. In other words, one Manager controlling eight Workers on a single 8-CPU-core server generates the same amount of load as a single standalone Goose process independently leveraging all eight cores.</p>
<p>Goose has a number of unique <a href="./logging/overview.html">debugging and logging mechanisms</a> not found in other load testing tools, simplifying the writing of load tests and the analysis of results. Goose also provides more <a href="./getting-started/metrics.html">comprehensive metrics</a> with multiple simple views into the data, and makes it easy to confirm that the load test is doing what you expect it to as you scale it up or down. It exposes the algorithms used to allocate tasks and task sets, giving <a href="./config/scheduler.html">more granular control</a> over the order and consistency of operations, important for easily repeatable testing.</p>
<h2 id="whats-missing"><a class="header" href="#whats-missing">What's Missing</a></h2>
<p>At this time, the biggest missing feature of Goose is a UI for controlling and monitoring load tests, but this is a work in progress. A recently completed first step toward this goal was the addition of an <a href="./getting-started/common.html#writing-an-html-formatted-report">optional HTML report</a> generated at the end of a load test.</p>
<h2 id="brought-to-you-by"><a class="header" href="#brought-to-you-by">Brought To You By</a></h2>
<p>Goose development is sponsored by <a href="https://tag1.com/">Tag1 Consulting</a>, led by Tag1's CEO, <a href="https://foundation.rust-lang.org/posts/2021-10-26-member-spotlight-tag1/">Jeremy Andrews</a>, along with many <a href="https://github.com/tag1consulting/goose/graphs/contributors">community contributions</a>. Tag1 is a <a href="https://www.tag1consulting.com/blog/tag1-joins-rust-foundation-first-silver-member">member of the Rust Foundation</a>.</p>
<h2 id="additional-documentation"><a class="header" href="#additional-documentation">Additional Documentation</a></h2>
<ul>
<li><a href="https://docs.rs/goose/">Developer documentation</a></li>
<li><a href="https://tag1.com/goose/">Blogs and more</a>
<ul>
<li><a href="https://www.tag1consulting.com/blog/jmeter-vs-locust-vs-goose">Goose vs Locust and jMeter</a></li>
<li><a href="https://www.tag1consulting.com/blog/real-life-goose-load-testing">Real-life load testing with Goose</a></li>
<li><a href="https://www.tag1consulting.com/blog/show-me-how-flock-flies-working-gaggle-goose">Gaggle: a distributed load test</a></li>
<li><a href="https://www.tag1consulting.com/blog/golden-goose-egg-compile-time-adventure">Optimizing Goose performance</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requirements"><a class="header" href="#requirements">Requirements</a></h1>
<ul>
<li>
<p>In order to write load tests, you must first install <a href="https://www.rust-lang.org/tools/install">Rust</a>.</p>
</li>
<li>
<p>Goose load tests are managed with <a href="https://doc.rust-lang.org/cargo/">Cargo</a>, the Rust package manager.</p>
</li>
<li>
<p>Goose requires a minimum <a href="https://doc.rust-lang.org/rustc/what-is-rustc.html"><code>rustc</code></a> version of <a href="https://blog.rust-lang.org/2020/12/31/Rust-1.49.0.html"><code>1.49.0</code></a> or later. This is because Goose depends on <a href="https://docs.rs/flume"><code>flume</code></a> for communication between threads, which in turn depends on <a href="https://docs.rs/spinning_top"><code>spinning_top</code></a> which uses <a href="https://doc.rust-lang.org/std/hint/fn.spin_loop.html"><code>hint::spin_loop</code></a> which stabilized in <code>rustc</code> version <code>1.49.0</code>. (See <a href="https://github.com/rust-lang/rust/issues/55002">https://github.com/rust-lang/rust/issues/55002</a> for more detail.)</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This first chapter of the Goose Book provides a high-level overview of writing and running Goose load tests. If you're new to Goose, this is the place to start.</p>
<h2 id="the-importance-of-load-testing"><a class="header" href="#the-importance-of-load-testing">The Importance Of Load Testing</a></h2>
<p>Load testing can help prevent website outages, stress test code changes, and identify bottlenecks. The ability to run the same test repeatedly gives critical insight into the impact of changes to the code and/or systems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-load-test"><a class="header" href="#creating-a-load-test">Creating A Load Test</a></h1>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo</a> is the Rust package manager. To create a new load test, use Cargo to create a new application (you can name your application anything, we've generically selected <code>loadtest</code>):</p>
<pre><code class="language-bash">$ cargo new loadtest
     Created binary (application) `loadtest` package
$ cd loadtest/
</code></pre>
<p>This creates a new directory named <code>loadtest/</code> containing <code>loadtest/Cargo.toml</code> and <code>loadtest/src/main.rs</code>. Edit <code>Cargo.toml</code> and add Goose and <a href="https://tokio.rs/"><code>Tokio</code></a> under the dependencies heading:</p>
<pre><code class="language-toml">[dependencies]
goose = &quot;^0.15&quot;
tokio = &quot;^1.12&quot;
</code></pre>
<p>At this point it's possible to compile all dependencies, though the resulting binary only displays &quot;Hello, world!&quot;:</p>
<pre><code class="language-bash">$ cargo run
    Updating crates.io index
  Downloaded goose v0.15.0
      ...
   Compiling goose v0.15.0
   Compiling loadtest v0.1.0 (/home/jandrews/devel/rust/loadtest)
    Finished dev [unoptimized + debuginfo] target(s) in 52.97s
     Running `target/debug/loadtest`
Hello, world!
</code></pre>
<p>To create an actual load test, you first have to add the following boilerplate to the top of <code>src/main.rs</code> to make Goose's functionality available to your code:</p>
<pre><code class="language-rust ignore">use goose::prelude::*;
</code></pre>
<blockquote>
<p><strong>Note:</strong> Using the above prelude automatically adds the following <code>use</code> statements necessary when writing a load test, so you don't need to manually add all of them:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::config::{GooseDefault, GooseDefaultType};
use crate::goose::{
    GooseMethod, GooseRequest, GooseTask, GooseTaskError, GooseTaskFunction, GooseTaskResult,
    GooseTaskSet, GooseUser,
};
use crate::metrics::{GooseCoordinatedOmissionMitigation, GooseMetrics};
use crate::{task, taskset, GooseAttack, GooseError, GooseScheduler};
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<p>Then create a new load testing function. For our example we're simply going to load the front page of the website we're load-testing. Goose passes all load testing functions a mutable pointer to a GooseUser object, which is used to track metrics and make web requests. Thanks to the Reqwest library, the Goose client manages things like cookies, headers, and sessions for you. Load testing functions must be declared async, ensuring that your simulated users don't become CPU-locked.</p>
<p>In load test functions you typically do not set the host, and instead configure the host at run time, so you can easily run your load test against different environments without recompiling. Relative paths (not starting with a &quot;/&quot;) should be used.</p>
<p>The following <code>loadtest_index</code> function simply loads the front page of our web page:</p>
<pre><code class="language-rust ignore">use goose::prelude::*;

async fn loadtest_index(user: &amp;mut GooseUser) -&gt; GooseTaskResult {
    let _goose_metrics = user.get(&quot;&quot;).await?;

    Ok(())
}
</code></pre>
<p>The function is declared <code>async</code> so that we don't block a CPU-core while loading web pages. All Goose load test functions are passed in a mutable reference to a <code>GooseUser</code> object, and return a <code>GooseTaskResult</code> which is either an empty <code>Ok(())</code> on success, or a <code>GooseTaskError</code> on failure. We use the <code>GooseUser</code> object to make requests, in this case we make a <code>GET</code> request for the front page, specified with an empty path <code>&quot;&quot;</code>. The <code>.await</code> frees up the CPU-core while we wait for the web page to respond, and the trailing <code>?</code> unwraps the response, returning any unexpected errors that may be generated by this request.</p>
<p>When the GET request completes, Goose returns metrics which we store in the  <code>_goose_metrics</code> variable. The variable is prefixed with an underscore (<code>_</code>) to tell the compiler we are intentionally not using the results. Finally, after making a single successful request, we return <code>Ok(())</code> to let Goose know this task function completed successfully.</p>
<p>Now we have to tell Goose about our new task function. Edit the <code>main()</code> function, setting a return type and replacing the hello world text as follows:</p>
<pre><code class="language-rust ignore">#[tokio::main]
async fn main() -&gt; Result&lt;(), GooseError&gt; {
    GooseAttack::initialize()?
        .register_taskset(taskset!(&quot;LoadtestTasks&quot;)
            .register_task(task!(loadtest_index))
        )
        .execute()
        .await?
        .print();

    Ok(())
}
</code></pre>
<p>The <code>#[tokio::main]</code> at the beginning of this example is a Tokio macro necessary because Goose is an asynchronous library, allowing (and requiring) us to declare the <code>main()</code> function of our load test application as <code>async</code>.</p>
<p>If you're new to Rust, <code>main()</code>'s return type of <code>Result&lt;(), GooseError&gt;</code> may look strange. It essentially says that <code>main</code> will return nothing (<code>()</code>) on success, and will return a <code>GooseError</code> on failure. This is helpful as several of <code>GooseAttack</code>'s methods can fail, returning an error. In our example, <code>initialize()</code> and <code>execute()</code> each may fail. The <code>?</code> that follows the method's name tells our program to exit and return an error on failure, otherwise continue on. Note that the <code>.execute()</code> method is asynchronous, so it must be followed with <code>.await</code>, and as it can return an error it alsos has a <code>?</code>. The <code>print()</code> method consumes the <code>GooseMetrics</code> object returned by <code>GooseAttack.execute()</code> and prints a summary if metrics are enabled. The final line, <code>Ok(())</code> returns the empty result expected on success.</p>
<p>And that's it, you've created your first load test! Read on to see how to run it and what it does.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-a-load-test"><a class="header" href="#running-a-load-test">Running A Load Test</a></h1>
<p>We will use Cargo to run our example load test application. It's best to get in the habit of setting the <code>--release</code> option whenever compiling or running load tests.</p>
<pre><code class="language-bash">$ cargo run --release
   Compiling loadtest v0.1.0 (/home/jandrews/devel/rust/loadtest)
    Finished dev [optimized] target(s) in 3.56s
     Running `target/release/loadtest`
Error: InvalidOption { option: &quot;--host&quot;, value: &quot;&quot;, detail: &quot;A host must be defined via the --host option, the GooseAttack.set_default() function, or the GooseTaskSet.set_host() function (no host defined for LoadtestTasks).&quot; }
</code></pre>
<p>The load test fails with an error as it hasn't been told the host you want to load test. So, let's try again, this time passing in the <code>--host</code> flag. After running for a few seconds, press <code>ctrl-c</code> to stop the load test:</p>
<pre><code class="language-bash">$ cargo run -- --host http://local.dev/
    Finished dev [optimized] target(s) in 0.07s
     Running `target/release/loadtest --host 'http://local.dev/'`

=== PER TASK METRICS ===
------------------------------------------------------------------------------
 Name                    | # times run    | # fails        | task/s | fail/s
 -----------------------------------------------------------------------------
 1: LoadtestTasks        |
   1:                    | 2,240          | 0 (0%)         | 280.0  | 0.000
-------------------------------------------------------------------------------
 Name                    | Avg (ms)   | Min        | Max        | Median
 -----------------------------------------------------------------------------
 1: LoadtestTasks        |
   1:                    | 15.54      | 6          | 136        | 14

=== PER REQUEST METRICS ===
------------------------------------------------------------------------------
 Name                    | # reqs         | # fails        | req/s  | fail/s
 -----------------------------------------------------------------------------
 GET /                   | 2,240          | 0 (0%)         | 280.0  | 0.000
-------------------------------------------------------------------------------
 Name                    | Avg (ms)   | Min        | Max        | Median
 -----------------------------------------------------------------------------
 GET /                   | 15.30      | 6          | 135        | 14

All 8 users hatched, resetting metrics (disable with --no-reset-metrics).

^C06:03:25 [ WARN] caught ctrl-c, stopping...

=== PER TASK METRICS ===
------------------------------------------------------------------------------
 Name                    | # times run    | # fails        | task/s | fail/s
 -----------------------------------------------------------------------------
 1: LoadtestTasks        |
   1:                    | 2,054          | 0 (0%)         | 410.8  | 0.000
-------------------------------------------------------------------------------
 Name                    | Avg (ms)   | Min        | Max        | Median
 -----------------------------------------------------------------------------
 1: LoadtestTasks        |
   1:                    | 20.86      | 7          | 254        | 19

=== PER REQUEST METRICS ===
------------------------------------------------------------------------------
 Name                    | # reqs         | # fails        | req/s  | fail/s
 -----------------------------------------------------------------------------
 GET /                   | 2,054          | 0 (0%)         | 410.8  | 0.000
-------------------------------------------------------------------------------
 Name                    | Avg (ms)   | Min        | Max        | Median
 -----------------------------------------------------------------------------
 GET /                   | 20.68      | 7          | 254        | 19
-------------------------------------------------------------------------------
 Slowest page load within specified percentile of requests (in ms):
 ------------------------------------------------------------------------------
 Name                    | 50%    | 75%    | 98%    | 99%    | 99.9%  | 99.99%
 -----------------------------------------------------------------------------
 GET /                   | 19     | 21     | 53     | 69     | 250    | 250
</code></pre>
<p>By default, Goose will hatch 1 <code>GooseUser</code> per second, up to the number of CPU cores available on the server used for load testing. In the above example, the server has 8 CPU cores, so it took 8 seconds to hatch all users. After all users are hatched, Goose flushes all metrics collected during the hatching process so all subsequent metrics are taken with all users running. Before flushing the metrics, they are displayed to the console so the data is not lost.</p>
<p>The same metrics are displayed per-task and per-request. In our simple example, our single task only makes one request, so in this case both metrics show the same results.</p>
<p>The per-task metrics are displayed first, starting with the name of our Task Set, <code>LoadtestTasks</code>. Individual tasks in the Task Set are then listed in the order they are defined in our load test. We did not name our task, so it simply shows up as &quot;1: &quot;. All defined tasks will be listed here, even if they did not run, so this can be useful to confirm everything in your load test is running as expected.</p>
<p>Next comes the per-request metrics. Our single task makes a <code>GET</code> request for the <code>/</code> path, so it shows up in the metrics as <code>GET /</code>. Comparing the per-task metrics collected for <code>1: </code> to the per-request metrics collected for <code>GET /</code>, you can see that they are the same.</p>
<p>There are two common tables found in each type of metrics. The first shows the total number of requests made (2,054), how many of those failed (0), the average number of requests per second (410.8), and the average number of failed requests per second (0).</p>
<p>The second table shows the average time required to load a page (20.68 milliseconds), the minimum time to load a page (7 ms), the maximum time to load a page (254 ms) and the median time to load a page (19 ms).</p>
<p>The per-request metrics include a third table, showing the slowest page load time for a range of percentiles. In our example, in the 50% fastest page loads, the slowest page loaded in 19 ms. In the 75% fastest page loads, the slowest page loaded in 21 ms, etc.</p>
<p>In real load tests, you'll most likely have multiple task sets each with multiple tasks, and Goose will show you metrics for each along with an aggregate of them all together.</p>
<p>Refer to the <a href="getting-started/../example/overview.html">examples</a> included with Goose for more complicated and useful load test examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run-time-options"><a class="header" href="#run-time-options">Run-Time Options</a></h1>
<p>The <code>-h</code> flag will show all run-time configuration options available to Goose load tests. For example, you can pass the <code>-h</code> flag to our example loadtest as follows, <code>cargo run --release -- -h</code>:</p>
<pre><code class="language-ignore">Usage: target/release/loadtest [OPTIONS]

Options available when launching a Goose load test.


Optional arguments:
  -h, --help                 Displays this help
  -V, --version              Prints version information
  -l, --list                 Lists all tasks and exits

  -H, --host HOST            Defines host to load test (ie http://10.21.32.33)
  -u, --users USERS          Sets concurrent users (default: number of CPUs)
  -r, --hatch-rate RATE      Sets per-second user hatch rate (default: 1)
  -s, --startup-time TIME    Starts users for up to (30s, 20m, 3h, 1h30m, etc)
  -t, --run-time TIME        Stops load test after (30s, 20m, 3h, 1h30m, etc)
  -G, --goose-log NAME       Enables Goose log file and sets name
  -g, --log-level            Sets Goose log level (-g, -gg, etc)
  -v, --verbose              Sets Goose verbosity (-v, -vv, etc)

Metrics:
  --running-metrics TIME     How often to optionally print running metrics
  --no-reset-metrics         Doesn't reset metrics after all users have started
  --no-metrics               Doesn't track metrics
  --no-task-metrics          Doesn't track task metrics
  --no-error-summary         Doesn't display an error summary
  --report-file NAME         Create an html-formatted report
  -R, --request-log NAME     Sets request log file name
  --request-format FORMAT    Sets request log format (csv, json, raw, pretty)
  --request-body             Include the request body in the request log
  -T, --task-log NAME        Sets task log file name
  --task-format FORMAT       Sets task log format (csv, json, raw, pretty)
  -E, --error-log NAME       Sets error log file name
  --error-format FORMAT      Sets error log format (csv, json, raw, pretty)
  -D, --debug-log NAME       Sets debug log file name
  --debug-format FORMAT      Sets debug log format (csv, json, raw, pretty)
  --no-debug-body            Do not include the response body in the debug log
  --status-codes             Tracks additional status code metrics

Advanced:
  --no-telnet                Doesn't enable telnet Controller
  --telnet-host HOST         Sets telnet Controller host (default: 0.0.0.0)
  --telnet-port PORT         Sets telnet Controller TCP port (default: 5116)
  --no-websocket             Doesn't enable WebSocket Controller
  --websocket-host HOST      Sets WebSocket Controller host (default: 0.0.0.0)
  --websocket-port PORT      Sets WebSocket Controller TCP port (default: 5117)
  --no-autostart             Doesn't automatically start load test
  --co-mitigation STRATEGY   Sets coordinated omission mitigation strategy
  --throttle-requests VALUE  Sets maximum requests per second
  --sticky-follow            Follows base_url redirect with subsequent requests

Gaggle:
  --manager                  Enables distributed load test Manager mode
  --expect-workers VALUE     Sets number of Workers to expect
  --no-hash-check            Tells Manager to ignore load test checksum
  --manager-bind-host HOST   Sets host Manager listens on (default: 0.0.0.0)
  --manager-bind-port PORT   Sets port Manager listens on (default: 5115)
  --worker                   Enables distributed load test Worker mode
  --manager-host HOST        Sets host Worker connects to (default: 127.0.0.1)
  --manager-port PORT        Sets port Worker connects to (default: 5115)
</code></pre>
<p>All of the above configuration options are <a href="https://docs.rs/goose/*/goose/config/struct.GooseConfiguration.html">defined in the developer documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-run-time-options"><a class="header" href="#common-run-time-options">Common Run Time Options</a></h1>
<p>As seen on the previous page, Goose has a lot of run time options which can be overwhelming. The following are a few of the more common and more important options to be familiar with. In these examples we only demonstrate one option at a time, but it's generally useful to combine many options.</p>
<h2 id="verbose-output"><a class="header" href="#verbose-output">Verbose Output</a></h2>
<p>By default Goose is not very verbose, and only outputs metrics at the end of a load test. It can be preferable to get more insight into what's going by enabling the <code>-v</code> flag to increase verbosity.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p><em>Enable verbose output while running load test.</em></p>
<pre><code class="language-bash">cargo run --release -- -v
</code></pre>
<h2 id="host-to-load-test"><a class="header" href="#host-to-load-test">Host to load test</a></h2>
<p>Load test plans typically contain relative paths, and so Goose must be told which host to run the load test against in order for it to start. This allows a single load test plan to be used for testing different environments, for example &quot;http://local.example.com&quot;, &quot;https://qa.example.com&quot;, and &quot;https://www.example.com&quot;.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p><em>Load test the https://www.example.com domain.</em></p>
<pre><code class="language-bash">cargo run --release -- -H https://www.example.com
</code></pre>
<h2 id="how-many-users-to-simulate"><a class="header" href="#how-many-users-to-simulate">How many users to simulate</a></h2>
<p>By default, Goose will launch one user per available CPU core. Often you will want to simulate considerably more users than this, and this can be done by setting the &quot;--user&quot; run time option.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<p><em>Launch 1,000 GooseUsers.</em></p>
<pre><code class="language-bash">cargo run --release -- -u 1000
</code></pre>
<h2 id="controlling-how-long-it-takes-goose-to-launch-all-users"><a class="header" href="#controlling-how-long-it-takes-goose-to-launch-all-users">Controlling how long it takes Goose to launch all users</a></h2>
<p>There are two ways to configure how long Goose will take to launch all configured GooseUsers. You can user either <code>--hatch-rate</code> or <code>--startup-time</code>, but not both together.</p>
<h3 id="specifying-the-hatch-rate"><a class="header" href="#specifying-the-hatch-rate">Specifying the hatch rate</a></h3>
<p>By default, Goose starts one GooseUser per second. So if you configure <code>--users</code> to 10 it will take ten seconds to fully start the load test. If you set <code>--hatch-rate 5</code> then Goose will start 5 users every second, taking two seconds to start up. If you set <code>--hatch-rate 0.5</code> then Goose will start 1 user every 2 seconds, taking twenty seconds to start all 10 users.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<p><em>Launch one user every two seconds.</em></p>
<pre><code class="language-bash">cargo run --release -- -r .5
</code></pre>
<h3 id="specifying-the-total-startup-time"><a class="header" href="#specifying-the-total-startup-time">Specifying the total startup time</a></h3>
<p>Alternatively, you can tell Goose how long you'd like it to take to start all GooseUsers. So, if you configure <code>--users</code> to 10 and set <code>--startup-time 10</code> it will launch 1 user every second. If you set <code>--start-time 1m</code> it will start 1 user every 6 seconds, starting all users over one minute. And if you set <code>--start-time 2s</code> it will launch five users per second, launching all users in two seconds.</p>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<p><em>Launch all users in 5 seconds.</em></p>
<pre><code class="language-bash">cargo run --release -- -s 5
</code></pre>
<h2 id="specifying-how-long-the-load-test-will-run"><a class="header" href="#specifying-how-long-the-load-test-will-run">Specifying how long the load test will run</a></h2>
<p>The <code>--run-time</code> option is not affected by how long Goose takes to start up. Thus, if you configure a load test with <code>--users 100 --start-time 30m --run-time 5m</code> Goose will run for a total of 35 minutes, first ramping up for 30 minutes and then running at full load for 5 minutes. If you want Goose to exit immediately after all users start, you can set a very small run time, for example <code>--users 100 --hatch-rate .25 --run-time 1s</code>.</p>
<p>If you do not configure a run time, Goose will run until it's canceled with <code>ctrl-c</code>.</p>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<p><em>Run the load test for 30 minutes.</em></p>
<pre><code class="language-bash">cargo run --release -- -t 30m
</code></pre>
<h2 id="writing-an-html-formatted-report"><a class="header" href="#writing-an-html-formatted-report">Writing An HTML-formatted Report</a></h2>
<p>By default, Goose displays <a href="getting-started/metrics.html">text-formatted metrics</a> when a load test finishes. It can also optionally write an HTML-formatted report if you enable the <code>--report-file &lt;NAME&gt;</code> run-time option, where <code>&lt;NAME&gt;</code> is an absolute or relative path to the report file to generate. Any file that already exists at the specified path will be overwritten.</p>
<h3 id="example-6"><a class="header" href="#example-6">Example</a></h3>
<p><em>Write an HTML-formatted report to <code>report.html</code> when the load test finishes.</em></p>
<pre><code class="language-bash">cargo run --release -- --report-file report.html
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="throttling-requests"><a class="header" href="#throttling-requests">Throttling Requests</a></h1>
<p>By default, Goose will generate as much load as it can. If this is not desirable, the throttle allows optionally limiting the maximum number of requests per second made during a load test. This can be helpful to ensure consistency when running a load test from multiple different servers with different available resources.</p>
<p>The throttle is specified as an integer and imposes a maximum number of requests, not a minimum number of requests.</p>
<h2 id="example-7"><a class="header" href="#example-7">Example</a></h2>
<p>In this example, Goose will launch 100 GooseUser threads, but the throttle will prevent them from generating a combined total of more than 5 requests per second.</p>
<pre><code class="language-bash">$ cargo run --release -- -H http://local.dev/ -u100 -r20 -v --throttle-requests 5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics"><a class="header" href="#metrics">Metrics</a></h1>
<p>Here's the output of running the loadtest. The <code>-v</code> flag sends <code>INFO</code> and more critical messages to stdout (in addition to the log file, if enabled). The <code>-u1024</code> tells Goose to spin up 1,024 users. The <code>-r32</code> option tells Goose to hatch 32 users per second. The <code>-t10m</code> option tells Goose to run the load test for 10 minutes, or 600 seconds. The <code>--status-codes</code> flag tells Goose to track metrics about HTTP status codes returned by the server, in addition to the default per-task and per-request metrics. The <code>--no-reset-metrics</code> flag tells Goose to track all metrics, instead of the default which is to flush all metrics collected during start up. And finally, the <code>--only-summary</code> flag tells Goose to only display the final metrics after the load test finishes, otherwise it would display running metrics every 15 seconds for the duration of the test.</p>
<pre><code class="language-bash">$ cargo run --release -- --host http://local.dev -v -u1024 -r32 -t10m --status-codes --no-reset-metrics --only-summary
    Finished release [optimized] target(s) in 0.09s
     Running `target/release/examples/simple --host 'http://local.dev' -v -u1024 -r32 -t10m --status-codes --no-reset-metrics --only-summary`
10:55:04 [ INFO] Output verbosity level: INFO
10:55:04 [ INFO] Logfile verbosity level: INFO
10:55:04 [ INFO] Writing to log file: goose.log
10:55:04 [ INFO] run_time = 600
10:55:04 [ INFO] global host configured: http://local.dev
10:55:04 [ INFO] initializing user states...
10:55:09 [ INFO] launching user 1 from WebsiteUser...
10:55:09 [ INFO] launching user 2 from WebsiteUser...
10:55:09 [ INFO] launching user 3 from WebsiteUser...
</code></pre>
<p>...</p>
<pre><code class="language-bash">10:55:42 [ INFO] launching user 1022 from WebsiteUser...
10:55:42 [ INFO] launching user 1023 from WebsiteUser...
10:55:42 [ INFO] launching user 1024 from WebsiteUser...
10:55:42 [ INFO] launched 1024 users...
All 1024 users hatched.

11:05:09 [ INFO] stopping after 600 seconds...
11:05:09 [ INFO] waiting for users to exit
11:05:09 [ INFO] exiting user 879 from WebsiteUser...
11:05:09 [ INFO] exiting user 41 from WebsiteUser...
11:05:09 [ INFO] exiting user 438 from WebsiteUser...
</code></pre>
<p>...</p>
<pre><code class="language-bash">11:05:10 [ INFO] exiting user 268 from WebsiteUser...
11:05:10 [ INFO] exiting user 864 from WebsiteUser...
11:05:10 [ INFO] exiting user 55 from WebsiteUser...
11:05:11 [ INFO] printing metrics after 601 seconds...

=== PER TASK METRICS ===
------------------------------------------------------------------------------
 Name                    | # times run    | # fails        | task/s | fail/s
 -----------------------------------------------------------------------------
 1: WebsiteUser          |
   1:                    | 1,024          | 0 (0%)         | 1.707  | 0.000
   2:                    | 28,746         | 0 (0%)         | 47.91  | 0.000
   3:                    | 28,748         | 0 (0%)         | 47.91  | 0.000
 ------------------------+----------------+----------------+--------+---------
 Aggregated              | 58,518         | 0 (0%)         | 97.53  | 0.000
-------------------------------------------------------------------------------
 Name                    | Avg (ms)   | Min        | Max        | Median
 -----------------------------------------------------------------------------
 1: WebsiteUser          |
   1:                    | 5.995      | 5          | 37         | 6
   2:                    | 0.428      | 0          | 17         | 0
   3:                    | 0.360      | 0          | 37         | 0
 ------------------------+------------+------------+------------+-------------
 Aggregated              | 0.492      | 5          | 37         | 5

=== PER REQUEST METRICS ===
------------------------------------------------------------------------------
 Name                    | # reqs         | # fails        | req/s  | fail/s
 -----------------------------------------------------------------------------
 GET /                   | 28,746         | 0 (0%)         | 47.91  | 0.000
 GET /about/             | 28,748         | 0 (0%)         | 47.91  | 0.000
 POST /login             | 1,024          | 0 (0%)         | 1.707  | 0.000
 ------------------------+----------------+----------------+--------+---------
 Aggregated              | 58,518         | 29,772 (50.9%) | 97.53  | 49.62
 -------------------------------------------------------------------------------
 Name                    | Avg (ms)   | Min        | Max        | Median
 -----------------------------------------------------------------------------
 GET /                   | 0.412      | 0          | 17         | 0
 GET /about/             | 0.348      | 0          | 37         | 0
 POST /login             | 5.979      | 5          | 37         | 6
 ------------------------+------------+------------+------------+-------------
 Aggregated              | 0.478      | 5          | 37         | 5
 -------------------------------------------------------------------------------
 Slowest page load within specified percentile of requests (in ms):
 ------------------------------------------------------------------------------
 Name                    | 50%    | 75%    | 98%    | 99%    | 99.9%  | 99.99%
 -----------------------------------------------------------------------------
 GET /                   | 0      | 1      | 3      | 4      | 5      | 5
 GET /about/             | 0      | 0      | 3      | 3      | 5      | 5
 POST /login             | 6      | 6      | 7      | 7      | 28     | 28
 ------------------------+--------+--------+--------+--------+--------+-------
 Aggregated              | 5      | 5      | 5      | 6      | 7      | 17
 -------------------------------------------------------------------------------
 Name                    | Status codes
 -----------------------------------------------------------------------------
 GET /                   | 28,746 [200]
 GET /about/             | 28,748 [200]
 POST /login             | 1,024 [200]
 -------------------------------------------------------------------------------
 Aggregated              | 58,518 [200]
 ------------------------------------------------------------------------------
 Users: 1024
 Target host: http://local.dev/
 Starting: 2021-08-12 10:55:04 - 2021-08-12 10:55:42 (duration: 00:00:38)
 Running:  2021-08-12 10:55:42 - 2021-08-12 11:05:09 (duration: 00:10:00)
 Stopping: 2021-08-12 11:05:09 - 2021-08-12 11:05:11 (duration: 00:00:02)

 goose v0.15.0
 ------------------------------------------------------------------------------
</code></pre>
<p>Additional details about how metrics are collected, stored, and displayed can be found <a href="https://docs.rs/goose/*/goose/metrics/index.html">in the developer documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tips"><a class="header" href="#tips">Tips</a></h1>
<ul>
<li>When writing load tests, avoid <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap"><code>unwrap()</code></a> (and variations) in your task functions -- Goose generates a lot of load, and this tends to trigger errors. Embrace Rust's warnings and properly handle all possible errors, this will save you time debugging later.</li>
<li>When running your load test, use the cargo <code>--release</code> flag to generate optimized code. This can generate considerably more load test traffic. Learn more about this and other optimizations in <a href="https://www.tag1consulting.com/blog/golden-goose-egg-compile-time-adventure">&quot;The golden Goose egg, a compile-time adventure&quot;</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>With logging, it's possible to record all Goose activity. This can be useful for debugging errors, for validating the load test, and for creating graphs.</p>
<p>When logging is enabled, a central logging thread maintains a buffer to minimize the IO overhead, and controls the writing to ensure that multiple threads don't corrupt each other's messages. All log messages are sent through a channel to the logging thread and written asynchronously, minimizing the impact on the load test.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="request-log"><a class="header" href="#request-log">Request Log</a></h1>
<p>Goose can optionally log details about all the requests made during the load test to a file. This log file contains the running metrics Goose generates as the load test runs. To enable, add the <code>--request-log &lt;request.log&gt;</code> command line option, where <code>&lt;request.log&gt;</code> is either a relative or absolute path of the log file to create. Any existing file that may already exist will be overwritten.</p>
<p>If <code>--request-body</code> is also enabled, the request log will include the entire body of any client requests.</p>
<p>Logs include the entire <a href="https://docs.rs/goose/*/goose/metrics/struct.GooseRequestMetric.html"><code>GooseRequestMetric</code></a> object which also includes the entire <a href="https://docs.rs/goose/*/goose/metrics/struct.GooseRawRequest.html"><code>GooseRawRequest</code></a> object, both created for all client requests.</p>
<h2 id="log-format"><a class="header" href="#log-format">Log Format</a></h2>
<p>By default, logs are written in JSON Lines format. For example (in this case with <code>--request-body</code> also enabled):</p>
<pre><code class="language-json">{&quot;coordinated_omission_elapsed&quot;:0,&quot;elapsed&quot;:13219,&quot;error&quot;:&quot;&quot;,&quot;final_url&quot;:&quot;http://apache/misc/jquery-extend-3.4.0.js?v=1.4.4&quot;,&quot;name&quot;:&quot;static asset&quot;,&quot;raw&quot;:{&quot;body&quot;:&quot;&quot;,&quot;headers&quot;:[],&quot;method&quot;:&quot;Get&quot;,&quot;url&quot;:&quot;http://apache/misc/jquery-extend-3.4.0.js?v=1.4.4&quot;},&quot;redirected&quot;:false,&quot;response_time&quot;:7,&quot;status_code&quot;:200,&quot;success&quot;:true,&quot;update&quot;:false,&quot;user&quot;:4,&quot;user_cadence&quot;:0}
{&quot;coordinated_omission_elapsed&quot;:0,&quot;elapsed&quot;:13055,&quot;error&quot;:&quot;&quot;,&quot;final_url&quot;:&quot;http://apache/node/1786#comment-114852&quot;,&quot;name&quot;:&quot;(Auth) comment form&quot;,&quot;raw&quot;:{&quot;body&quot;:&quot;subject=this+is+a+test+comment+subject&amp;comment_body%5Bund%5D%5B0%5D%5Bvalue%5D=this+is+a+test+comment+body&amp;comment_body%5Bund%5D%5B0%5D%5Bformat%5D=filtered_html&amp;form_build_id=form-U0L3wm2SsIKAhVhaHpxeL1TLUHW64DXKifmQeZsUsss&amp;form_token=VKDel_jiYzjqPrekL1FrP2_4EqHTlsaqLjMUJ6pn-sE&amp;form_id=comment_node_article_form&amp;op=Save&quot;,&quot;headers&quot;:[&quot;(\&quot;content-type\&quot;, \&quot;application/x-www-form-urlencoded\&quot;)&quot;],&quot;method&quot;:&quot;Post&quot;,&quot;url&quot;:&quot;http://apache/comment/reply/1786&quot;},&quot;redirected&quot;:true,&quot;response_time&quot;:172,&quot;status_code&quot;:200,&quot;success&quot;:true,&quot;update&quot;:false,&quot;user&quot;:1,&quot;user_cadence&quot;:0}
{&quot;coordinated_omission_elapsed&quot;:0,&quot;elapsed&quot;:13219,&quot;error&quot;:&quot;&quot;,&quot;final_url&quot;:&quot;http://apache/misc/drupal.js?q9apdy&quot;,&quot;name&quot;:&quot;static asset&quot;,&quot;raw&quot;:{&quot;body&quot;:&quot;&quot;,&quot;headers&quot;:[],&quot;method&quot;:&quot;Get&quot;,&quot;url&quot;:&quot;http://apache/misc/drupal.js?q9apdy&quot;},&quot;redirected&quot;:false,&quot;response_time&quot;:7,&quot;status_code&quot;:200,&quot;success&quot;:true,&quot;update&quot;:false,&quot;user&quot;:0,&quot;user_cadence&quot;:0}
</code></pre>
<p>The <code>--request-format</code> option can be used to log in <code>csv</code>, <code>json</code> (default), <code>raw</code> or <code>pretty</code> format. The <code>raw</code> format is Rust's debug output of the entire <a href="https://docs.rs/goose/*/goose/metrics/struct.GooseRequestMetric.html"><code>GooseRequestMetric</code></a> object.</p>
<h2 id="gaggle-mode"><a class="header" href="#gaggle-mode">Gaggle Mode</a></h2>
<p>When operating in Gaggle-mode, the <code>--request-log</code> option can only be enabled on the Worker processes, configuring Goose to spread out the overhead of writing logs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="task-log"><a class="header" href="#task-log">Task Log</a></h1>
<p>Goose can optionally log details about each time a task is run during a load test.  To enable, add the <code>--task-log &lt;task.log&gt;</code> command line option, where <code>&lt;task.log&gt;</code> is either a relative or absolute path of the log file to create. Any existing file that may already exist will be overwritten.</p>
<p>Logs include the entire <a href="https://docs.rs/goose/*/goose/metrics/struct.GooseTaskMetric.html"><code>GooseTaskMetric</code></a> object which is created each tiem any task is run.</p>
<h2 id="log-format-1"><a class="header" href="#log-format-1">Log Format</a></h2>
<p>By default, logs are written in JSON Lines format. For example:</p>
<pre><code class="language-json">{&quot;elapsed&quot;:22060,&quot;name&quot;:&quot;(Anon) front page&quot;,&quot;run_time&quot;:97,&quot;success&quot;:true,&quot;task_index&quot;:0,&quot;taskset_index&quot;:0,&quot;user&quot;:0}
{&quot;elapsed&quot;:22118,&quot;name&quot;:&quot;(Anon) node page&quot;,&quot;run_time&quot;:41,&quot;success&quot;:true,&quot;task_index&quot;:1,&quot;taskset_index&quot;:0,&quot;user&quot;:5}
{&quot;elapsed&quot;:22157,&quot;name&quot;:&quot;(Anon) node page&quot;,&quot;run_time&quot;:6,&quot;success&quot;:true,&quot;task_index&quot;:1,&quot;taskset_index&quot;:0,&quot;user&quot;:0}
{&quot;elapsed&quot;:22078,&quot;name&quot;:&quot;(Auth) front page&quot;,&quot;run_time&quot;:109,&quot;success&quot;:true,&quot;task_index&quot;:1,&quot;taskset_index&quot;:1,&quot;user&quot;:6}
{&quot;elapsed&quot;:22157,&quot;name&quot;:&quot;(Anon) user page&quot;,&quot;run_time&quot;:35,&quot;success&quot;:true,&quot;task_index&quot;:2,&quot;taskset_index&quot;:0,&quot;user&quot;:4}
</code></pre>
<p>In the first line of the above example, <code>GooseUser</code> thread 0 succesfully ran the <code>(Anon) front page</code> task in 97 milliseconds. In the second line <code>GooseUser</code> thread 5 succesfully ran the <code>(Anon) node page</code> task in 41 milliseconds.</p>
<p>The <code>--task-format</code> option can be used to log in <code>csv</code>, <code>json</code> (default), <code>raw</code> or <code>pretty</code> format. The <code>raw</code> format is Rust's debug output of the entire 
<a href="https://docs.rs/goose/*/goose/metrics/struct.GooseTaskMetric.html"><code>GooseTaskMetric</code></a> object.</p>
<p>For example, <code>csv</code> output of similar tasks as those logged above would like like:</p>
<pre><code class="language-csv">elapsed,taskset_index,task_index,name,run_time,success,user
21936,0,0,&quot;(Anon) front page&quot;,83,true,0
21990,1,3,&quot;(Auth) user page&quot;,34,true,1
21954,0,0,&quot;(Anon) front page&quot;,84,true,5
22009,0,1,&quot;(Anon) node page&quot;,34,true,2
21952,0,0,&quot;(Anon) front page&quot;,95,true,7
</code></pre>
<h1 id="gaggle-mode-1"><a class="header" href="#gaggle-mode-1">Gaggle Mode</a></h1>
<p>When operating in Gaggle-mode, the <code>--task-log</code> option can only be enabled on the Worker processes, configuring Goose to spread out the overhead of writing logs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-log"><a class="header" href="#error-log">Error Log</a></h1>
<p>Goose can optionally log details about all load test errors to a file. To enable, add the <code>--error-file=&lt;error.log&gt;</code> command line option, where <code>&lt;error.log&gt;</code> is either a relative or absolute path of the log file to create. Any existing file that may already exist will be overwritten.</p>
<p>Logs include the entire <a href="https://docs.rs/goose/*/goose/metrics/struct.GooseErrorMetric.html"><code>GooseErrorMetric</code></a> object, created any time a request results in an error.</p>
<h2 id="log-format-2"><a class="header" href="#log-format-2">Log Format</a></h2>
<p>By default, logs are written in JSON Lines format. For example:</p>
<pre><code class="language-json">{&quot;elapsed&quot;:9318,&quot;error&quot;:&quot;503 Service Unavailable: /&quot;,&quot;final_url&quot;:&quot;http://apache/&quot;,&quot;name&quot;:&quot;(Auth) front page&quot;,&quot;raw&quot;:{&quot;body&quot;:&quot;&quot;,&quot;headers&quot;:[],&quot;method&quot;:&quot;Get&quot;,&quot;url&quot;:&quot;http://apache/&quot;},&quot;redirected&quot;:false,&quot;response_time&quot;:6,&quot;status_code&quot;:503,&quot;user&quot;:1}
{&quot;elapsed&quot;:9318,&quot;error&quot;:&quot;503 Service Unavailable: /node/8211&quot;,&quot;final_url&quot;:&quot;http://apache/node/8211&quot;,&quot;name&quot;:&quot;(Anon) node page&quot;,&quot;raw&quot;:{&quot;body&quot;:&quot;&quot;,&quot;headers&quot;:[],&quot;method&quot;:&quot;Get&quot;,&quot;url&quot;:&quot;http://apache/node/8211&quot;},&quot;redirected&quot;:false,&quot;response_time&quot;:6,&quot;status_code&quot;:503,&quot;user&quot;:3}
</code></pre>
<p>The <code>--errors-format</code> option can be used to change the log format to <code>csv</code>, <code>json</code> (default), <code>raw</code> or <code>pretty</code> format. The <code>raw</code> format is Rust's debug output of the entire <a href="https://docs.rs/goose/*/goose/metrics/struct.GooseErrorMetric.html"><code>GooseErrorMetric</code></a> object.</p>
<h2 id="gaggle-mode-2"><a class="header" href="#gaggle-mode-2">Gaggle Mode</a></h2>
<p>When operating in Gaggle-mode, the <code>--error-file</code> option can only be enabled on the Worker processes, configuring Goose to spread out the overhead of writing logs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug-log"><a class="header" href="#debug-log">Debug Log</a></h1>
<p>Goose can optionally and efficiently log arbitrary details, and specifics about requests and responses for debug purposes.</p>
<p>To enable, add the <code>--debug-log &lt;debug.log&gt;</code> command line option, where <code>&lt;debug.log&gt;</code> is either a relative or absolute path of the log file to create. Any existing file that may already exist will be overwritten.</p>
<p>If <code>--debug-log &lt;foo&gt;</code> is not specified at run time, nothing will be logged and there is no measurable overhead in your load test.</p>
<p>To write to the debug log, you must invoke <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html#method.log_debug"><code>log_debug</code></a> from your load test task functions. The <code>tag</code> parameter allows you to record any arbitrary string: it can also identify where in the load test the log was generated, and/or why debug is being written, and/or other details such as the contents of a form the load test posts. Other paramters that can be included in the debug log are the complete Request that was made, as well as the Headers and Body of the Response.</p>
<p>(<em>Known limitations in Reqwest prevent all headers from being recorded: <a href="https://github.com/tag1consulting/goose/issues/336">https://github.com/tag1consulting/goose/issues/336</a></em>)</p>
<p>See <a href="https://github.com/tag1consulting/goose/blob/main/examples/drupal_loadtest.rs"><code>examples/drupal_loadtest</code></a> for an example of how you might invoke <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html#method.log_debug"><code>log_debug</code></a> from a load test.</p>
<h2 id="request-failures"><a class="header" href="#request-failures">Request Failures</a></h2>
<p>Calls to <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html#method.set_failure"><code>set_failure</code></a> can be used to tell Goose that a request failed even though the server returned a successful status code, and will automatically invoke <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html#method.log_debug"><code>log_debug</code></a> for you. See <a href="https://github.com/tag1consulting/goose/blob/main/examples/drupal_loadtest.rs"><code>examples/drupal_loadtest</code></a> and <a href="https://github.com/tag1consulting/goose/tree/main/examples/umami"><code>examples/umami</code></a> for an example of how you might use <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html#method.set_failure"><code>set_failure</code></a> to generate useful debug logs.</p>
<h2 id="log-format-3"><a class="header" href="#log-format-3">Log Format</a></h2>
<p>By default, logs are written in JSON Lines format. For example:</p>
<pre><code class="language-json">{&quot;body&quot;:&quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;503 Backend fetch failed&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Error 503 Backend fetch failed&lt;/h1&gt;\n    &lt;p&gt;Backend fetch failed&lt;/p&gt;\n    &lt;h3&gt;Guru Meditation:&lt;/h3&gt;\n    &lt;p&gt;XID: 1506620&lt;/p&gt;\n    &lt;hr&gt;\n    &lt;p&gt;Varnish cache server&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n&quot;,&quot;header&quot;:&quot;{\&quot;date\&quot;: \&quot;Mon, 19 Jul 2021 09:21:58 GMT\&quot;, \&quot;server\&quot;: \&quot;Varnish\&quot;, \&quot;content-type\&quot;: \&quot;text/html; charset=utf-8\&quot;, \&quot;retry-after\&quot;: \&quot;5\&quot;, \&quot;x-varnish\&quot;: \&quot;1506619\&quot;, \&quot;age\&quot;: \&quot;0\&quot;, \&quot;via\&quot;: \&quot;1.1 varnish (Varnish/6.1)\&quot;, \&quot;x-varnish-cache\&quot;: \&quot;MISS\&quot;, \&quot;x-varnish-cookie\&quot;: \&quot;SESSd7e04cba6a8ba148c966860632ef3636=Z50aRHuIzSE5a54pOi-dK_wbxYMhsMwrG0s2WM2TS20\&quot;, \&quot;content-length\&quot;: \&quot;284\&quot;, \&quot;connection\&quot;: \&quot;keep-alive\&quot;}&quot;,&quot;request&quot;:{&quot;coordinated_omission_elapsed&quot;:0,&quot;elapsed&quot;:9162,&quot;error&quot;:&quot;503 Service Unavailable: /node/1439&quot;,&quot;final_url&quot;:&quot;http://apache/node/1439&quot;,&quot;name&quot;:&quot;(Auth) comment form&quot;,&quot;raw&quot;:{&quot;body&quot;:&quot;&quot;,&quot;headers&quot;:[],&quot;method&quot;:&quot;Get&quot;,&quot;url&quot;:&quot;http://apache/node/1439&quot;},&quot;redirected&quot;:false,&quot;response_time&quot;:5,&quot;status_code&quot;:503,&quot;success&quot;:false,&quot;update&quot;:false,&quot;user&quot;:1,&quot;user_cadence&quot;:0},&quot;tag&quot;:&quot;post_comment: no form_build_id found on node/1439&quot;}
</code></pre>
<p>The <code>--debug-format</code> option can be used to log in <code>csv</code>, <code>json</code> (default), <code>raw</code> or <code>pretty</code> format. The <code>raw</code> format is Rust's debug output of the entire <a href="https://docs.rs/goose/*/goose/goose/struct.GooseDebug.html"><code>GooseDebug</code></a> object.</p>
<h2 id="gaggle-mode-3"><a class="header" href="#gaggle-mode-3">Gaggle Mode</a></h2>
<p>When operating in Gaggle-mode, the <code>--debug-log</code> option can only be enabled on the Worker processes, configuring Goose to spread out the overhead of writing logs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="controlling-a-running-goose-load-test"><a class="header" href="#controlling-a-running-goose-load-test">Controlling A Running Goose Load Test</a></h1>
<p>By default, Goose will launch a telnet Controller thread that listens on <code>0.0.0.0:5116</code>, and a WebSocket Controller thread that listens on <code>0.0.0.0:5117</code>. The running Goose load test can be controlled through these Controllers. Goose can optionally be started with the <code>--no-autostart</code> run time option to prevent the load test from automatically starting, requiring instead that it be started with a Controller command. When Goose is started this way, a host is not required and can instead be configured via the Controller.</p>
<p>NOTE: The controller currently is not Gaggle-aware, and only functions correctly when running Goose as a single process in standalone mode.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="telnet-controller"><a class="header" href="#telnet-controller">Telnet Controller</a></h1>
<p>The host and port that the telnet Controller listens on can be configured at start time with <code>--telnet-host</code> and <code>--telnet-port</code>. The telnet Controller can be completely disabled with the <code>--no-telnet</code> command line option. The defaults can be changed with <a href="https://docs.rs/goose/*/goose/config/enum.GooseDefault.html#variant.TelnetHost"><code>GooseDefault::TelnetHost</code></a>,<a href="https://docs.rs/goose/*/goose/config/enum.GooseDefault.html#variant.TelnetPort"><code>GooseDefault::TelnetPort</code></a>, and <a href="https://docs.rs/goose/*/goose/config/enum.GooseDefault.html#variant.NoTelnet"><code>GooseDefault::NoTelnet</code></a>.</p>
<h2 id="controller-commands"><a class="header" href="#controller-commands">Controller Commands</a></h2>
<p>To learn about all available commands, telnet into the Controller thread and enter <code>help</code> (or <code>?</code>). For example:</p>
<pre><code class="language-bash">% telnet localhost 5116
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
goose&gt; ?
goose 0.15.0 controller commands:
 help (?)           this help
 exit (quit)        exit controller
 start              start an idle load test
 stop               stop a running load test and return to idle state
 shutdown           shutdown running load test (and exit controller)
 host HOST          set host to load test, ie http://localhost/
 users INT          set number of simulated users
 hatchrate FLOAT    set per-second rate users hatch
 runtime TIME       set how long to run test, ie 1h30m5s
 config             display load test configuration
 config-json        display load test configuration in json format
 metrics            display metrics for current load test
 metrics-json       display metrics for current load test in json format
goose&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="websocket-controller"><a class="header" href="#websocket-controller">WebSocket Controller</a></h1>
<p>The host and port that the WebSocket Controller listens on can be configured at start time with <code>--websocket-host</code> and <code>--websocket-port</code>. The WebSocket Controller can be completely disabled with the <code>--no-websocket</code> command line option. The defaults can be changed with <a href="https://docs.rs/goose/*/goose/config/enum.GooseDefault.html#variant.WebSocketHost"><code>GooseDefault::WebSocketHost</code></a>,<a href="https://docs.rs/goose/*/goose/config/enum.GooseDefault.html#variant.WebSocketPort"><code>GooseDefault::WebSocketPort</code></a>, and <a href="https://docs.rs/goose/*/goose/config/enum.GooseDefault.html#variant.NoWebSocket"><code>GooseDefault::NoWebSocket</code></a>.</p>
<h2 id="details"><a class="header" href="#details">Details</a></h2>
<p>The WebSocket Controller supports the same commands listed in the <a href="controller/telnet.html">telnet controller</a>. Requests and Responses are in JSON format.</p>
<p>Requests must be made in the following format:</p>
<pre><code class="language-json">{
  &quot;request&quot;: String,
}
</code></pre>
<p>For example, a client should send the follow json to request the current load test metrics:</p>
<pre><code class="language-json">{
  &quot;request&quot;: &quot;metrics&quot;,
}
</code></pre>
<p>Responses will always be in the following format:</p>
<pre><code class="language-json">{
  &quot;response&quot;: String,
  &quot;success&quot;: Boolean,
}
</code></pre>
<p>For example:</p>
<pre><code class="language-bash">% websocat ws://127.0.0.1:5117
foo
{&quot;response&quot;:&quot;unable to parse json, see Goose README.md&quot;,&quot;success&quot;:false}
{&quot;request&quot;: &quot;foo&quot;}
{&quot;response&quot;:&quot;unrecognized command, see Goose README.md&quot;,&quot;success&quot;:false}
{&quot;request&quot;: &quot;config&quot;}
{&quot;response&quot;:&quot;{\&quot;help\&quot;:false,\&quot;version\&quot;:false,\&quot;list\&quot;:false,\&quot;host\&quot;:\&quot;http://apache/\&quot;,\&quot;users\&quot;:5,\&quot;hatch_rate\&quot;:\&quot;.5\&quot;,\&quot;run_time\&quot;:\&quot;\&quot;,\&quot;log_level\&quot;:0,\&quot;goose_log\&quot;:\&quot;\&quot;,\&quot;verbose\&quot;:1,\&quot;running_metrics\&quot;:null,\&quot;no_reset_metrics\&quot;:false,\&quot;no_metrics\&quot;:false,\&quot;no_task_metrics\&quot;:false,\&quot;no_error_summary\&quot;:false,\&quot;report_file\&quot;:\&quot;\&quot;,\&quot;request_log\&quot;:\&quot;\&quot;,\&quot;request_format\&quot;:\&quot;json\&quot;,\&quot;debug_log\&quot;:\&quot;\&quot;,\&quot;debug_format\&quot;:\&quot;json\&quot;,\&quot;no_debug_body\&quot;:false,\&quot;status_codes\&quot;:false,\&quot;no_telnet\&quot;:false,\&quot;telnet_host\&quot;:\&quot;0.0.0.0\&quot;,\&quot;telnet_port\&quot;:5116,\&quot;no_websocket\&quot;:false,\&quot;websocket_host\&quot;:\&quot;0.0.0.0\&quot;,\&quot;websocket_port\&quot;:5117,\&quot;no_autostart\&quot;:true,\&quot;throttle_requests\&quot;:0,\&quot;sticky_follow\&quot;:false,\&quot;manager\&quot;:false,\&quot;expect_workers\&quot;:null,\&quot;no_hash_check\&quot;:false,\&quot;manager_bind_host\&quot;:\&quot;\&quot;,\&quot;manager_bind_port\&quot;:0,\&quot;worker\&quot;:false,\&quot;manager_host\&quot;:\&quot;\&quot;,\&quot;manager_port\&quot;:0}&quot;,&quot;success&quot;:true}
{&quot;request&quot;: &quot;stop&quot;}
{&quot;response&quot;:&quot;load test not running, failed to stop&quot;,&quot;success&quot;:false}
{&quot;request&quot;: &quot;exit&quot;}
{&quot;response&quot;:&quot;goodbye!&quot;,&quot;success&quot;:true}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gaggle-distributed-load-test"><a class="header" href="#gaggle-distributed-load-test">Gaggle: Distributed Load Test</a></h1>
<p>Goose also supports distributed load testing. A Gaggle is one Goose process running in <a href="gaggle/manager.html">Manager mode</a>, and 1 or more Goose processes running in <a href="gaggle/worker.html">Worker mode</a>. The Manager coordinates starting and stopping the Workers, and collects aggregated metrics. Gaggle support is a <a href="gaggle/technical.html#compile-time-feature">cargo feature that must be enabled at compile-time</a>. To launch a Gaggle, you must copy your load test application to all servers from which you wish to generate load.</p>
<p>It is strongly recommended that the same load test application be copied to all servers involved in a Gaggle. By default, Goose will verify that the load test is identical by comparing a hash of all load test rules. Telling it to skip this check can cause the load test to panic (for example, if a Worker defines a different number of tasks or task sets than the Manager).</p>
<h2 id="load-testing-at-scale"><a class="header" href="#load-testing-at-scale">Load Testing At Scale</a></h2>
<p>Experimenting with running Goose load tests from AWS, Goose has proven to make fantastic use of all available system resources, so that it is only generally limited by network speeds. A smaller server instance was able to simulate 2,000 users generating over 6,500 requests per second and saturating a 2.6 Gbps uplink. As more uplink speed was added, Goose was able to scale linearly -- by distributing the test across two servers with faster uplinks, it comfortably simulated 12,000 active users generating over 41,000 requests per second and saturating 16 Gbps.</p>
<p>Generating this much traffic in and of itself is not fundamentally difficult, but with Goose each request is fully analyzed and validated. It not only confirms the response code for each response the server returns, but also inspects the returned HTML to confirm it contains all expected elements. Links to static elements such as images and CSS are extracted from each response and also loaded, with each simulated user behaving similar to how a real user would. Goose excels at providing consistent and repeatable load testing.</p>
<p>For full details and graphs, refer to the blog <a href="https://www.tag1consulting.com/blog/goose-clouds-load-testing-scale">A Goose In The Clouds: Load Testing At Scale</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gaggle-manager"><a class="header" href="#gaggle-manager">Gaggle Manager</a></h1>
<p>To launch a Gaggle, you first must start a Goose application in Manager mode. All configuration happens in the Manager. To start, add the <code>--manager</code> flag and <code>--expect-workers</code> option, the latter necessary to tell the Manager process how many Worker processes it will be coordinating.</p>
<h2 id="example-8"><a class="header" href="#example-8">Example</a></h2>
<p><em>Configure a Goose Manager to listen on all interfaces on the default port (0.0.0.0:5115), waiting for 2 Goose Worker processes.</em></p>
<pre><code class="language-bash">cargo run --features gaggle --example simple -- --manager --expect-workers 2 --host http://local.dev/ -v
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gaggle-worker"><a class="header" href="#gaggle-worker">Gaggle Worker</a></h1>
<p>At this time, a Goose process can be either a Manager or a Worker, not both. Therefor, it usually makes sense to launch your first Worker on the same server that the Manager is running on. If not otherwise configured, a Goose Worker will try to connect to the Manager on the localhost.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Starting a Worker that connects to a Manager running on the same server:</p>
<pre><code class="language-bash">cargo run --features gaggle --example simple -- --worker -v
</code></pre>
<p>In our <a href="gaggle/manager.html">earlier example</a>, we expected 2 Workers. The second Goose process should be started on a different server. This will require telling it the host where the Goose Manager process is running. For example:</p>
<pre><code class="language-bash">cargo run --example simple -- --worker --manager-host 192.168.1.55 -v
</code></pre>
<p>Once all expected Workers are running, the distributed load test will automatically start. We set the <code>-v</code> flag so Goose provides verbose output indicating what is happening. In our example, the load test will run until it is canceled. You can cancel the Manager or either of the Worker processes, and the test will stop on all servers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run-time-flags"><a class="header" href="#run-time-flags">Run-time Flags</a></h1>
<ul>
<li><code>--manager</code>: starts a Goose process in Manager mode. There currently can only be one Manager per Gaggle.</li>
<li><code>--worker</code>: starts a Goose process in Worker mode. How many Workers are in a given Gaggle is defined by the <code>--expect-workers</code> option, documented below.</li>
<li><code>--no-hash-check</code>: tells Goose to ignore if the load test application doesn't match between Worker(s) and the Manager. This is not recommended, and can cause the application to panic.</li>
</ul>
<p>The <code>--no-metrics</code>, <code>--only-summary</code>, <code>--no-reset-metrics</code>, <code>--status-codes</code>, and <code>--no-hash-check</code> flags must be set on the Manager. Workers inherit these flags from the Manager</p>
<h1 id="run-time-options-1"><a class="header" href="#run-time-options-1">Run-time Options</a></h1>
<ul>
<li><code>--manager-bind-host &lt;manager-bind-host&gt;</code>: configures the host that the Manager listens on. By default Goose will listen on all interfaces, or <code>0.0.0.0</code>.</li>
<li><code>--manager-bind-port &lt;manager-bind-port&gt;</code>: configures the port that the Manager listens on. By default Goose will listen on port <code>5115</code>.</li>
<li><code>--manager-host &lt;manager-host&gt;</code>: configures the host that the Worker will talk to the Manager on. By default, a Goose Worker will connect to the localhost, or <code>127.0.0.1</code>. In a distributed load test, this must be set to the IP of the Goose Manager.</li>
<li><code>--manager-port &lt;manager-port&gt;</code>: configures the port that a Worker will talk to the Manager on. By default, a Goose Worker will connect to port <code>5115</code>.</li>
</ul>
<p>The <code>--users</code>, <code>--startup-time</code>, <code>--hatch-rate</code>, <code>--host</code>, and <code>--run-time</code> options must be set on the Manager. Workers inherit these options from the Manager.</p>
<p>The <code>--throttle-requests</code> option must be configured on each Worker, and can be set to a different value on each Worker if desired.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gaggle-technical-details"><a class="header" href="#gaggle-technical-details">Gaggle Technical Details</a></h1>
<p>Goose uses <a href="https://docs.rs/nng/"><code>nng</code></a> to send network messages between the Manager and all Workers. <a href="https://docs.serde.rs/serde/index.html">Serde</a> and <a href="https://github.com/pyfisch/cbor">Serde CBOR</a> are used to serialize messages into <a href="https://tools.ietf.org/html/rfc7049">Concise Binary Object Representation</a>.</p>
<p>Workers initiate all network connections, and push metrics to the Manager process.</p>
<h2 id="compile-time-feature"><a class="header" href="#compile-time-feature">Compile-time Feature</a></h2>
<p>Gaggle support is a compile-time Cargo feature that must be enabled. Goose uses the <a href="https://docs.rs/nng/"><code>nng</code></a> library to manage network connections, and compiling <code>nng</code> requires that <code>cmake</code> be available.</p>
<p>The <code>gaggle</code> feature can be enabled from the command line by adding <code>--features gaggle</code> to your cargo command.</p>
<p>When writing load test applications, you can default to compiling in the Gaggle feature in the <code>dependencies</code> section of your <code>Cargo.toml</code>, for example:</p>
<pre><code class="language-toml">[dependencies]
goose = { version = &quot;^0.15&quot;, features = [&quot;gaggle&quot;] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coordinated-omission"><a class="header" href="#coordinated-omission">Coordinated Omission</a></h1>
<p>When Coordinated Omission mitigation is enabled, Goose attempts to mitigate the loss of metrics data (Coordinated Omission) caused by an abnormally lengthy response to a request.</p>
<h2 id="definition"><a class="header" href="#definition">Definition</a></h2>
<p>To understand Coordinated Omission and how Goose attempts to mitigate it, it's necessary to understand how Goose is scheduling requests. Goose launches one thread per <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a>. Each <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> is assigned a single <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTaskSet.html"><code>GooseTaskSet</code></a>. Each of these <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> threads then loop repeatedly through all of the <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTask.html"><code>GooseTasks</code></a> defined in the assigned <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTaskSet.html"><code>GooseTaskSet</code></a>, each of which can involve any number of individual requests. However, at any given time, each <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> is only making a single request and then asynchronously waiting for the response.</p>
<p>If something causes the response to a request to take abnormally long, raw Goose metrics only see this slowdown as affecting a specific request (or one request per <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a>. The slowdown can be caused by a variety of issues, such as a resource bottleneck (on the Goose client or the web server), garbage collection, a cache stampede, or even a network issue. A real user loading the same web page would see a much larger effect, as all requests to the affected server would stall. Even static assets such as images and scripts hosted on a reliable and fast CDN can be affected, as the web browser won't know to load them until it first loads the HTML from the affected web server. Because Goose is only making one request at a time per <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a>, it may only see one or very few slow requests and then all other requests resume at normal speed. This results in a bias in the metrics to &quot;ignore&quot; or &quot;hide&quot; the true effect of a slowdown, commonly referred to as Coordinated Omission.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mitigation"><a class="header" href="#mitigation">Mitigation</a></h1>
<p>Goose can optionally attempt to mitigate <a href="coordinated-omission/overview.html#definition">Coordinated Omission</a> by back-filling the metrics with the statistically expected requests. To do this, it tracks the normal &quot;cadence&quot; of each <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a>, timing how long it takes to loop through all <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTask.html"><code>GooseTasks</code></a> in the assigned <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTaskSet.html"><code>GooseTaskSet</code></a>. By default, Goose will trigger Coordinated Omission Mitigation if the time to loop through a <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTaskSet.html"><code>GooseTaskSet</code></a> takes more than twice as long as the average time of all previous loops. In this case, on the next loop through the <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTaskSet.html"><code>GooseTaskSet</code></a> when tracking the actual metrics for each subsequent request in all <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTask.html"><code>GooseTasks</code></a> it will also add in statistically generated &quot;requests&quot; with a <a href="https://docs.rs/goose/*/goose/metrics/struct.GooseRequestMetric.html#structfield.response_time"><code>response_time</code></a> starting at the unexpectedly long request time, then again with that <a href="https://docs.rs/goose/*/goose/metrics/struct.GooseRequestMetric.html#structfield.response_time"><code>response_time</code></a> minus the normal &quot;cadence&quot;, continuing to generate a metric then subtract the normal &quot;cadence&quot; until arriving at the expected <a href="https://docs.rs/goose/*/goose/metrics/struct.GooseRequestMetric.html#structfield.response_time"><code>response_time</code></a>. In this way, Goose is able to estimate the actual effect of a slowdown.</p>
<p>When Goose detects an abnormally slow request (one in which the individual request takes longer than the normal <a href="https://docs.rs/goose/*/goose/metrics/struct.GooseRequestMetric.html#structfield.user_cadence"><code>user_cadence</code></a>), it will generate an INFO level message (which will be visible if Goose was started with the <code>-v</code> run time flag, or written to the log if started with the <code>-g</code> run time flag and <code>--goose-log</code> is configured).</p>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>An example of a request triggering Coordinate Omission mitigation:</p>
<pre><code class="language-bash">13:10:30 [INFO] 11.401s into goose attack: &quot;GET http://apache/node/1557&quot; [200] took abnormally long (1814 ms), task name: &quot;(Anon) node page&quot;
13:10:30 [INFO] 11.450s into goose attack: &quot;GET http://apache/node/5016&quot; [200] took abnormally long (1769 ms), task name: &quot;(Anon) node page&quot;
</code></pre>
<p>If the <code>--request-log</code> is enabled, you can get more details, in this case by looking for elapsed times matching the above messages, specifically 1,814 and 1,769 respectively:</p>
<pre><code class="language-json">{&quot;coordinated_omission_elapsed&quot;:0,&quot;elapsed&quot;:11401,&quot;error&quot;:&quot;&quot;,&quot;final_url&quot;:&quot;http://apache/node/1557&quot;,&quot;method&quot;:&quot;Get&quot;,&quot;name&quot;:&quot;(Anon) node page&quot;,&quot;redirected&quot;:false,&quot;response_time&quot;:1814,&quot;status_code&quot;:200,&quot;success&quot;:true,&quot;update&quot;:false,&quot;url&quot;:&quot;http://apache/node/1557&quot;,&quot;user&quot;:2,&quot;user_cadence&quot;:1727}
{&quot;coordinated_omission_elapsed&quot;:0,&quot;elapsed&quot;:11450,&quot;error&quot;:&quot;&quot;,&quot;final_url&quot;:&quot;http://apache/node/5016&quot;,&quot;method&quot;:&quot;Get&quot;,&quot;name&quot;:&quot;(Anon) node page&quot;,&quot;redirected&quot;:false,&quot;response_time&quot;:1769,&quot;status_code&quot;:200,&quot;success&quot;:true,&quot;update&quot;:false,&quot;url&quot;:&quot;http://apache/node/5016&quot;,&quot;user&quot;:0,&quot;user_cadence&quot;:1422}
</code></pre>
<p>In the requests file, you can see that two different user threads triggered Coordinated Omission Mitigation, specifically threads 2 and 0. Both <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> threads were loading the same <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTask.html"><code>GooseTask</code></a> as due to task weighting this is the task loaded the most frequently. Both <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> threads loop through all <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTask.html"><code>GooseTasks</code></a> in a similar amount of time: thread 2 takes on average 1.727 seconds, thread 0 takes on average 1.422 seconds.</p>
<p>Also if the <code>--request-log</code> is enabled, requests back-filled by Coordinated Omission Mitigation show up in the generated log file, even though they were not actually sent to the server. Normal requests not generated by Coordinated Omission Mitigation have a <a href="https://docs.rs/goose/*/goose/metrics/struct.GooseRequestMetric.html#structfield.coordinated_omission_elapsed"><code>coordinated_omission_elapsed</code></a> of 0.</p>
<p>Coordinated Omission Mitigation is disabled by default. It can be enabled with the <code>--co-mitigation</code> run time option when starting Goose. It can be configured to use the <a href="https://docs.rs/goose/*/goose/metrics/enum.GooseCoordinatedOmissionMitigation.html#variant.Average"><code>average</code></a>, <a href="https://docs.rs/goose/*/goose/metrics/enum.GooseCoordinatedOmissionMitigation.html#variant.Minimum"><code>minimum</code></a>, or <a href="https://docs.rs/goose/*/goose/metrics/enum.GooseCoordinatedOmissionMitigation.html#variant.Maximum"><code>maximum</code></a> <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> cadence when backfilling statistics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics-1"><a class="header" href="#metrics-1">Metrics</a></h1>
<p>When Coordinated Omission Mitigation kicks in, Goose tracks both the &quot;raw&quot; metrics and the &quot;adjusted&quot; metrics. It shows both together when displaying metrics, first the &quot;raw&quot; (actually seen) metrics, followed by the &quot;adjusted&quot; metrics. As the minimum response time is never changed by Coordinated Omission Mitigation, this column is replacd with the &quot;standard deviation&quot; between the average &quot;raw&quot; response time, and the average &quot;adjusted&quot; response time.</p>
<p>The following example was &quot;contrived&quot;. The <a href="coordinated-omission/../example/drupal-memcache.html"><code>drupal_memcache</code></a> example was run for 15 seconds, and after 10 seconds the upstream Apache server was manually &quot;paused&quot; for 3 seconds, forcing some abnormally slow queries. (More specifically, the apache web server was started by running <code>. /etc/apache2/envvars &amp;&amp; /usr/sbin/apache2 -DFOREGROUND</code>, it was &quot;paused&quot; by pressing <code>ctrl-z</code>, and it was resumed three seconds later by typing <code>fg</code>.) In the &quot;PER REQUEST METRICS&quot; Goose shows first the &quot;raw&quot; metrics&quot;, followed by the &quot;adjusted&quot; metrics:</p>
<pre><code class="language-bash"> ------------------------------------------------------------------------------
 Name                     |    Avg (ms) |        Min |         Max |     Median
 ------------------------------------------------------------------------------
 GET (Anon) front page    |       11.73 |          3 |          81 |         12
 GET (Anon) node page     |       81.76 |          5 |       3,390 |         37
 GET (Anon) user page     |       27.53 |         16 |          94 |         26
 GET (Auth) comment form  |       35.27 |         24 |          50 |         35
 GET (Auth) front page    |       30.68 |         20 |         111 |         26
 GET (Auth) node page     |       97.79 |         23 |       3,326 |         35
 GET (Auth) user page     |       25.20 |         21 |          30 |         25
 GET static asset         |        9.27 |          2 |          98 |          6
 POST (Auth) comment form |       52.47 |         43 |          59 |         52
 -------------------------+-------------+------------+-------------+-----------
 Aggregated               |       17.04 |          2 |       3,390 |          8
 ------------------------------------------------------------------------------
 Adjusted for Coordinated Omission:
 ------------------------------------------------------------------------------
 Name                     |    Avg (ms) |    Std Dev |         Max |     Median
 ------------------------------------------------------------------------------
 GET (Anon) front page    |      419.82 |     288.56 |       3,153 |         14
 GET (Anon) node page     |      464.72 |     270.80 |       3,390 |         40
 GET (Anon) user page     |      420.48 |     277.86 |       3,133 |         27
 GET (Auth) comment form  |      503.38 |     331.01 |       2,951 |         37
 GET (Auth) front page    |      489.99 |     324.78 |       2,960 |         33
 GET (Auth) node page     |      530.29 |     305.82 |       3,326 |         37
 GET (Auth) user page     |      500.67 |     336.21 |       2,959 |         27
 GET static asset         |      427.70 |     295.87 |       3,154 |          9
 POST (Auth) comment form |      512.14 |     325.04 |       2,932 |         55
 -------------------------+-------------+------------+-------------+-----------
 Aggregated               |      432.98 |     294.11 |       3,390 |         14
</code></pre>
<p>From these two tables, it is clear that there was a statistically significant event affecting the load testing metrics. In particular, note that the standard deviation between the &quot;raw&quot; average and the &quot;adjusted&quot; average is considerably larger than the &quot;raw&quot; average, calling into questing whether or not your load test was &quot;valid&quot;. (The answer to that question depends very much on your specific goals and load test.)</p>
<p>Goose also shows multiple percentile graphs, again showing first the &quot;raw&quot; metrics followed by the &quot;adjusted&quot; metrics. The &quot;raw&quot; graph would suggest that less than 1% of the requests for the <code>GET (Anon) node page</code> were slow, and less than 0.1% of the requests for the <code>GET (Auth) node page</code> were slow. However, through Coordinated Omission Mitigation we can see that statistically this would have actually affected all requests, and for authenticated users the impact is visible on &gt;25% of the requests.</p>
<pre><code class="language-bash"> ------------------------------------------------------------------------------
 Slowest page load within specified percentile of requests (in ms):
 ------------------------------------------------------------------------------
 Name                     |    50% |    75% |    98% |    99% |  99.9% | 99.99%
 ------------------------------------------------------------------------------
 GET (Anon) front page    |     12 |     15 |     25 |     27 |     81 |     81
 GET (Anon) node page     |     37 |     43 |     60 |  3,000 |  3,000 |  3,000
 GET (Anon) user page     |     26 |     28 |     34 |     93 |     94 |     94
 GET (Auth) comment form  |     35 |     37 |     50 |     50 |     50 |     50
 GET (Auth) front page    |     26 |     34 |     45 |     88 |    110 |    110
 GET (Auth) node page     |     35 |     38 |     58 |     58 |  3,000 |  3,000
 GET (Auth) user page     |     25 |     27 |     30 |     30 |     30 |     30
 GET static asset         |      6 |     14 |     21 |     22 |     81 |     98
 POST (Auth) comment form |     52 |     55 |     59 |     59 |     59 |     59
 -------------------------+--------+--------+--------+--------+--------+-------
 Aggregated               |      8 |     16 |     47 |     53 |  3,000 |  3,000
 ------------------------------------------------------------------------------
 Adjusted for Coordinated Omission:
 ------------------------------------------------------------------------------
 Name                     |    50% |    75% |    98% |    99% |  99.9% | 99.99%
 ------------------------------------------------------------------------------
 GET (Anon) front page    |     14 |     21 |  3,000 |  3,000 |  3,000 |  3,000
 GET (Anon) node page     |     40 |     55 |  3,000 |  3,000 |  3,000 |  3,000
 GET (Anon) user page     |     27 |     32 |  3,000 |  3,000 |  3,000 |  3,000
 GET (Auth) comment form  |     37 |    400 |  2,951 |  2,951 |  2,951 |  2,951
 GET (Auth) front page    |     33 |    410 |  2,960 |  2,960 |  2,960 |  2,960
 GET (Auth) node page     |     37 |    410 |  3,000 |  3,000 |  3,000 |  3,000
 GET (Auth) user page     |     27 |    420 |  2,959 |  2,959 |  2,959 |  2,959
 GET static asset         |      9 |     20 |  3,000 |  3,000 |  3,000 |  3,000
 POST (Auth) comment form |     55 |    390 |  2,932 |  2,932 |  2,932 |  2,932
 -------------------------+--------+--------+--------+--------+--------+-------
 Aggregated               |     14 |     42 |  3,000 |  3,000 |  3,000 |  3,000
</code></pre>
<p>The Coordinated Omission metrics will also show up in the HTML report generated when Goose is started with the <code>--report-file</code> run-time option. If Coordinated Omission mitigation kicked in, the HTML report will include both the &quot;raw&quot; metrics and the &quot;adjusted&quot; metrics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>Configuration of Goose load tests is done in Rust code within the load test plan. Complete documentation of all load test configuration can be found in the <a href="https://docs.rs/goose">developer documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defaults"><a class="header" href="#defaults">Defaults</a></h1>
<p>All run-time options can be configured with custom defaults. For example, you may want to default to the the host name of your local development environment, only requiring that <code>--host</code> be set when running against a production environment. Assuming your local development environment is at &quot;http://local.dev/&quot; you can do this as follows:</p>
<pre><code class="language-rust ignore">    GooseAttack::initialize()?
        .register_taskset(taskset!(&quot;LoadtestTasks&quot;)
            .register_task(task!(loadtest_index))
        )
        .set_default(GooseDefault::Host, &quot;http://local.dev/&quot;)?
        .execute()
        .await?
        .print();

    Ok(())
</code></pre>
<p>The following defaults can be configured with a <code>&amp;str</code>:</p>
<ul>
<li>host: <code>GooseDefault::Host</code></li>
<li>log file name: <code>GooseDefault::LogFile</code></li>
<li>html-formatted report file name: <code>GooseDefault::ReportFile</code></li>
<li>requests log file name: <code>GooseDefault::RequestsFile</code></li>
<li>requests log file format: <code>GooseDefault::RequestsFormat</code></li>
<li>debug log file name: <code>GooseDefault::DebugFile</code></li>
<li>debug log file format: <code>GooseDefault::DebugFormat</code></li>
<li>host to bind telnet Controller to: <code>GooseDefault::TelnetHost</code></li>
<li>host to bind WebSocket Controller to: <code>GooseDefault::WebSocketHost</code></li>
<li>host to bind Manager to: <code>GooseDefault::ManagerBindHost</code></li>
<li>host for Worker to connect to: <code>GooseDefault::ManagerHost</code></li>
</ul>
<p>The following defaults can be configured with a <code>usize</code> integer:</p>
<ul>
<li>total users to start: <code>GooseDefault::Users</code></li>
<li>users to start per second: <code>GooseDefault::HatchRate</code></li>
<li>how often to print running metrics: <code>GooseDefault::RunningMetrics</code></li>
<li>number of seconds for test to run: <code>GooseDefault::RunTime</code></li>
<li>log level: <code>GooseDefault::LogLevel</code></li>
<li>verbosity: <code>GooseDefault::Verbose</code></li>
<li>maximum requests per second: <code>GooseDefault::ThrottleRequests</code></li>
<li>number of Workers to expect: <code>GooseDefault::ExpectWorkers</code></li>
<li>port to bind telnet Controller to: <code>GooseDefault::TelnetPort</code></li>
<li>port to bind WebSocket Controller to: <code>GooseDefault::WebSocketPort</code></li>
<li>port to bind Manager to: <code>GooseDefault::ManagerBindPort</code></li>
<li>port for Worker to connect to: <code>GooseDefault::ManagerPort</code></li>
</ul>
<p>The following defaults can be configured with a <code>bool</code>:</p>
<ul>
<li>do not reset metrics after all users start: <code>GooseDefault::NoResetMetrics</code></li>
<li>do not track metrics: <code>GooseDefault::NoMetrics</code></li>
<li>do not track task metrics: <code>GooseDefault::NoTaskMetrics</code></li>
<li>do not start telnet Controller thread: <code>GooseDefault::NoTelnet</code></li>
<li>do not start WebSocket Controller thread: <code>GooseDefault::NoWebSocket</code></li>
<li>do not autostart load test, wait instead for a Controller to start: <code>GooseDefault::NoAutoStart</code></li>
<li>track status codes: <code>GooseDefault::StatusCodes</code></li>
<li>follow redirect of base_url: <code>GooseDefault::StickyFollow</code></li>
<li>enable Manager mode: <code>GooseDefault::Manager</code></li>
<li>ignore load test checksum: <code>GooseDefault::NoHashCheck</code></li>
<li>enable Worker mode: <code>GooseDefault::Worker</code></li>
</ul>
<p>The following defaults can be configured with a <code>GooseCoordinatedOmissionMitigation</code>:</p>
<ul>
<li>default Coordinated Omission Mitigation strategy: <code>GooseDefault::CoordinatedOmissionMitigation</code></li>
</ul>
<p>For example, without any run-time options the following load test would automatically run against <code>local.dev</code>, logging metrics to <code>goose-metrics.log</code> and debug to <code>goose-debug.log</code>. It will automatically launch 20 users in 4 seconds, and run the load test for 15 minutes. Metrics will be displayed every minute during the test and will include additional status code metrics. The order the defaults are set is not important.</p>
<pre><code class="language-rust ignore">    GooseAttack::initialize()?
        .register_taskset(taskset!(&quot;LoadtestTasks&quot;)
            .register_task(task!(loadtest_index))
        )
        .set_default(GooseDefault::Host, &quot;local.dev&quot;)?
        .set_default(GooseDefault::RequestsFile, &quot;goose-requests.log&quot;)?
        .set_default(GooseDefault::DebugFile, &quot;goose-debug.log&quot;)?
        .set_default(GooseDefault::Users, 20)?
        .set_default(GooseDefault::HatchRate, 4)?
        .set_default(GooseDefault::RunTime, 900)?
        .set_default(GooseDefault::RunningMetrics, 60)?
        .set_default(GooseDefault::StatusCodes, true)?
        .execute()
        .await?
        .print();

    Ok(())
</code></pre>
<p>Find a complete list of all configuration options that can be configured with custom defaults <a href="https://docs.rs/goose/*/goose/config/enum.GooseDefault.html">in the developer documentation</a>, as well as complete details on <a href="https://docs.rs/goose/*/goose/config/trait.GooseDefaultType.html">how to configure defaults</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scheduling-users-and-tasks"><a class="header" href="#scheduling-users-and-tasks">Scheduling Users And Tasks</a></h1>
<p>When starting a load test, Goose assigns one <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTaskSet.html"><code>GooseTaskSet</code></a> to each <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> thread. By default, it assigns <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTaskSet.html"><code>GooseTaskSet</code></a> (and then <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTask.html"><code>GooseTask</code></a> within the task set) in a round robin order. As new <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> threads are launched, the first will be assigned the first defined <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTaskSet.html"><code>GooseTaskSet</code></a>, the next will be assigned the next defined <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTaskSet.html"><code>GooseTaskSet</code></a>, and so on, looping through all available <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTaskSet.html"><code>GooseTaskSet</code></a>. Weighting is respected during this process, so if one <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTaskSet.html"><code>GooseTaskSet</code></a> is weighted heavier than others, that <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTaskSet.html"><code>GooseTaskSet</code></a> will get assigned to <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> more at the end of the launching process.</p>
<p>The <a href="https://docs.rs/goose/*/goose/enum.GooseScheduler.html"><code>GooseScheduler</code></a> can be configured to instead launch <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTaskSet.html"><code>GooseTaskSet</code></a> and <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTask.html"><code>GooseTask</code></a> in a <a href="https://docs.rs/goose/*/goose/enum.GooseScheduler.html#variant.Serial"><code>Serial</code></a> or a <a href="https://docs.rs/goose/*/goose/enum.GooseScheduler.html#variant.Random"><code>Random order</code></a>. When configured to allocate in a <a href="https://docs.rs/goose/*/goose/enum.GooseScheduler.html#variant.Serial"><code>Serial</code></a> order, <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTaskSet.html"><code>GooseTaskSet</code></a> and <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTask.html"><code>GooseTask</code></a> are launched in the extact order they are defined in the load test (see below for more detail on how this works). When configured to allocate in a <a href="https://docs.rs/goose/*/goose/enum.GooseScheduler.html#variant.Random"><code>Random</code></a> order, running the same load test multiple times can lead to different amounts of load being generated.</p>
<p>Prior to Goose <code>0.10.6</code> <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTaskSet.html"><code>GooseTaskSet</code></a> were allocated in a serial order. Prior to Goose <code>0.11.1</code> <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTask.html"><code>GooseTask</code></a> were allocated in a serial order. To restore the old behavior, you can use the <a href="https://docs.rs/goose/*/goose/struct.GooseAttack.html#method.set_scheduler"><code>GooseAttack::set_scheduler()</code></a> method as follows:</p>
<pre><code class="language-rust ignore">    GooseAttack::initialize()?
        .set_scheduler(GooseScheduler::Serial);
</code></pre>
<p>To instead randomize the order that <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTaskSet.html"><code>GooseTaskSet</code></a> and <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTask.html"><code>GooseTask</code></a> are allocated, you can instead configure as follows:</p>
<pre><code class="language-rust ignore">    GooseAttack::initialize()?
        .set_scheduler(GooseScheduler::Random);
</code></pre>
<p>The following configuration is possible but superfluous because it is the scheduling default, and is therefor how Goose behaves even if the <a href="https://docs.rs/goose/*/goose/struct.GooseAttack.html#method.set_scheduler"><code>.set_scheduler()</code></a> method is not called at all:</p>
<pre><code class="language-rust ignore">    GooseAttack::initialize()?
        .set_scheduler(GooseScheduler::RoundRobin);
</code></pre>
<h2 id="scheduling-example"><a class="header" href="#scheduling-example">Scheduling Example</a></h2>
<p>The following simple example helps illustrate how the different schedulers work.</p>
<pre><code class="language-rust ignore">use goose::prelude::*;

#[tokio::main]
async fn main() -&gt; Result&lt;(), GooseError&gt; {
    GooseAttack::initialize()?
        .register_taskset(taskset!(&quot;TaskSet1&quot;)
            .register_task(task!(task1).set_weight(2)?)
            .register_task(task!(task2))
            .set_weight(2)?
        )
        .register_taskset(taskset!(&quot;TaskSet2&quot;)
            .register_task(task!(task1))
            .register_task(task!(task2).set_weight(2)?)
        )
        .execute()
        .await?
        .print();

    Ok(())
}
</code></pre>
<h2 id="round-robin-scheduler"><a class="header" href="#round-robin-scheduler">Round Robin Scheduler</a></h2>
<p>This first example assumes the default of <code>.set_scheduler(GooseScheduler::RoundRobin)</code>.</p>
<p>If Goose is told to launch only two users, the first <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> will run <code>TaskSet1</code> and the second user will run <code>TaskSet2</code>. Even though <code>TaskSet1</code> has a weight of 2 <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> are allocated round-robin so with only two users the second instance of <code>TaskSet1</code> is never launched.</p>
<p>The <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> running <code>TaskSet1</code> will then launch tasks repeatedly in the following order: <code>task1</code>, <code>task2</code>, <code>task1</code>. If it runs through twice, then it runs all of the following tasks in the following order: <code>task1</code>, <code>task2</code>, <code>task1</code>, <code>task1</code>, <code>task2</code>, <code>task1</code>.</p>
<h2 id="serial-scheduler"><a class="header" href="#serial-scheduler">Serial Scheduler</a></h2>
<p>This second example assumes the manual configuration of <code>.set_scheduler(GooseScheduler::Serial)</code>.</p>
<p>If Goose is told to launch only two users, then both <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> will launch <code>TaskSet1</code> as it has a weight of 2. <code>TaskSet2</code> will not get assigned to either of the users.</p>
<p>Both <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> running <code>TaskSet1</code> will then launch tasks repeatedly in the following order: <code>task1</code>, <code>task1</code>, <code>task2</code>. If it runs through twice, then it runs all of the following tasks in the following order: <code>task1</code>, <code>task1</code>, <code>task2</code>, <code>task1</code>, <code>task1</code>, <code>task2</code>.</p>
<h2 id="random-scheduler"><a class="header" href="#random-scheduler">Random Scheduler</a></h2>
<p>This third example assumes the manual configuration of <code>.set_scheduler(GooseScheduler::Random)</code>.</p>
<p>If Goose is told to launch only two users, the first will be randomly assigned either <code>TaskSet1</code> or <code>TaskSet2</code>. Regardless of which is assigned to the first user, the second will again be randomly assigned either <code>TaskSet1</code> or <code>TaskSet2</code>. If the load test is stopped and run again, there users are randomly re-assigned, there is no consistency between load test runs.</p>
<p>Each <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> will run tasks in a random order. The random order will be determined at start time and then will run repeatedly in this random order as long as the user runs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustls"><a class="header" href="#rustls">RustLS</a></h1>
<p>By default Reqwest (and therefore Goose) uses the system-native transport layer security to make HTTPS requests. This means <code>schannel</code> on Windows, <code>Security-Framework</code> on macOS, and <code>OpenSSL</code> on Linux. If you'd prefer to use a <a href="https://github.com/ctz/rustls">pure Rust TLS implementation</a>, disable default features and enable <code>rustls-tls</code> in <code>Cargo.toml</code> as follows:</p>
<pre><code class="language-toml">[dependencies]
goose = { version = &quot;^0.15&quot;, default-features = false, features = [&quot;rustls-tls&quot;] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-2"><a class="header" href="#examples-2">Examples</a></h1>
<p>Goose includes several examples to demonstrate load test functionality, including:</p>
<ul>
<li><a href="example/simple.html">Simple</a> <em>(<a href="https://github.com/tag1consulting/goose/blob/main/examples/simple.rs">examples/simple.rs</a>)</em></li>
<li><a href="example/closure.html">Closure</a> <em>(<a href="https://github.com/tag1consulting/goose/blob/main/examples/closure.rs">examples/closure.rs</a>)</em></li>
<li><a href="example/session.html">Session</a> <em>(<a href="https://github.com/tag1consulting/goose/blob/main/examples/session.rs">examples/session.rs</a>)</em></li>
<li><a href="example/drupal-memcache.html">Drupal Memcache</a> <em>(<a href="https://github.com/tag1consulting/goose/blob/main/examples/drupal_memcache.rs">examples/drupal_memcache.rs</a>)</em></li>
<li><a href="example/umami.html">Umami</a> <em>(<a href="https://github.com/tag1consulting/goose/tree/main/examples/umami">examples/umami/</a>)</em></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-example"><a class="header" href="#simple-example">Simple Example</a></h1>
<p>The <a href="https://github.com/tag1consulting/goose/blob/main/examples/simple.rs"><code>examples/simple.rs</code></a> example copies the simple load test documented on the <a href="https://locust.io/">locust.io web page</a>, rewritten in Rust for Goose. It uses minimal advanced functionality, but demonstrates how to GET and POST pages. It defines a single Task Set which has the user log in and then load a couple of pages.</p>
<p>Goose can make use of all available CPU cores. By default, it will launch 1 user per core, and it can be configured to launch many more. The following was configured instead to launch 1,024 users. Each user randomly pauses 5 to 15 seconds after each task is loaded, so it's possible to spin up a large number of users. Here is a snapshot of <code>top</code> when running this example on a 1-core VM with 10G of available RAM -- there were ample resources to launch considerably more &quot;users&quot;, though <code>ulimit</code> had to be resized:</p>
<pre><code class="language-bash">top - 06:56:06 up 15 days,  3:13,  2 users,  load average: 0.22, 0.10, 0.04
Tasks: 116 total,   3 running, 113 sleeping,   0 stopped,   0 zombie
%Cpu(s):  1.7 us,  0.7 sy,  0.0 ni, 96.7 id,  0.0 wa,  0.0 hi,  1.0 si,  0.0 st
MiB Mem :   9994.9 total,   7836.8 free,   1101.2 used,   1056.9 buff/cache
MiB Swap:  10237.0 total,  10237.0 free,      0.0 used.   8606.9 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
 1339 goose     20   0 1235480 758292   8984 R   3.0   7.4   0:06.56 simple
</code></pre>
<h2 id="complete-source-code"><a class="header" href="#complete-source-code">Complete Source Code</a></h2>
<pre><code class="language-rust ignore">//! Simple Goose load test example. Duplicates the simple example on the
//! Locust project page (https://locust.io/).
//!
//! ## License
//!
//! Copyright 2020 Jeremy Andrews
//!
//! Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//! you may not use this file except in compliance with the License.
//! You may obtain a copy of the License at
//!
//! http://www.apache.org/licenses/LICENSE-2.0
//!
//! Unless required by applicable law or agreed to in writing, software
//! distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//! See the License for the specific language governing permissions and
//! limitations under the License.

use goose::prelude::*;
use std::time::Duration;

#[tokio::main]
async fn main() -&gt; Result&lt;(), GooseError&gt; {
    GooseAttack::initialize()?
        // In this example, we only create a single taskset, named &quot;WebsiteUser&quot;.
        .register_taskset(
            taskset!(&quot;WebsiteUser&quot;)
                // After each task runs, sleep randomly from 5 to 15 seconds.
                .set_wait_time(Duration::from_secs(5), Duration::from_secs(15))?
                // This task only runs one time when the user first starts.
                .register_task(task!(website_login).set_on_start())
                // These next two tasks run repeatedly as long as the load test is running.
                .register_task(task!(website_index))
                .register_task(task!(website_about)),
        )
        .execute()
        .await?
        .print();

    Ok(())
}

/// Demonstrates how to log in when a user starts. We flag this task as an
/// on_start task when registering it above. This means it only runs one time
/// per user, when the user thread first starts.
async fn website_login(user: &amp;mut GooseUser) -&gt; GooseTaskResult {
    let params = [(&quot;username&quot;, &quot;test_user&quot;), (&quot;password&quot;, &quot;&quot;)];
    let _goose = user.post_form(&quot;/login&quot;, &amp;params).await?;

    Ok(())
}

/// A very simple task that simply loads the front page.
async fn website_index(user: &amp;mut GooseUser) -&gt; GooseTaskResult {
    let _goose = user.get(&quot;/&quot;).await?;

    Ok(())
}

/// A very simple task that simply loads the about page.
async fn website_about(user: &amp;mut GooseUser) -&gt; GooseTaskResult {
    let _goose = user.get(&quot;/about/&quot;).await?;

    Ok(())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closure-example"><a class="header" href="#closure-example">Closure Example</a></h1>
<p>The <a href="https://github.com/tag1consulting/goose/blob/main/examples/closure.rs"><code>examples/closure.rs</code></a> example loads three different pages on a web site. Instead of defining a hard coded <a href="https://docs.rs/goose/*/goose/goose/struct.GooseTask.html"><code>GooseTask</code></a> function for each, the paths are passed in via a <a href="https://doc.rust-lang.org/std/vec/index.html">vector</a> and the <a href="https://docs.rs/goose/*/goose/goose/type.GooseTaskFunction.html">GooseTaskFunction</a> is dynamically created in a <a href="https://doc.rust-lang.org/rust-by-example/fn/closures.html">closure</a>.</p>
<h2 id="details-1"><a class="header" href="#details-1">Details</a></h2>
<p>The paths to be loaded are first defiend in a vector:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let paths = vec![&quot;/&quot;, &quot;/about&quot;, &quot;/our-team&quot;];
<span class="boring">}
</span></code></pre></pre>
<p>A task function for each path is then dynamically created as a closure:</p>
<pre><code class="language-rust ignore">    for request_path in paths {
        let path = request_path;

        let closure: GooseTaskFunction = Arc::new(move |user| {
            Box::pin(async move {
                let _goose = user.get(path).await?;

                Ok(())
            })
        });
</code></pre>
<h2 id="complete-source-code-1"><a class="header" href="#complete-source-code-1">Complete Source Code</a></h2>
<pre><code class="language-rust ignore">//! Simple Goose load test example using closures.
//!
//! ## License
//!
//! Copyright 2020 Fabian Franz
//!
//! Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//! you may not use this file except in compliance with the License.
//! You may obtain a copy of the License at
//!
//! http://www.apache.org/licenses/LICENSE-2.0
//!
//! Unless required by applicable law or agreed to in writing, software
//! distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//! See the License for the specific language governing permissions and
//! limitations under the License.

use goose::prelude::*;
use std::boxed::Box;
use std::sync::Arc;
use std::time::Duration;

#[tokio::main]
async fn main() -&gt; Result&lt;(), GooseError&gt; {
    let mut taskset = taskset!(&quot;WebsiteUser&quot;)
        // After each task runs, sleep randomly from 5 to 15 seconds.
        .set_wait_time(Duration::from_secs(5), Duration::from_secs(15))?;

    let paths = vec![&quot;/&quot;, &quot;/about&quot;, &quot;/our-team&quot;];
    for request_path in paths {
        let path = request_path;

        let closure: GooseTaskFunction = Arc::new(move |user| {
            Box::pin(async move {
                let _goose = user.get(path).await?;

                Ok(())
            })
        });

        let task = GooseTask::new(closure);
        // We need to do the variable dance as taskset.register_task returns self and hence moves
        // self out of `taskset`. By storing it in a new local variable and then moving it over
        // we can avoid that error.
        let new_taskset = taskset.register_task(task);
        taskset = new_taskset;
    }

    GooseAttack::initialize()?
        // In this example, we only create a single taskset, named &quot;WebsiteUser&quot;.
        .register_taskset(taskset)
        .execute()
        .await?
        .print();

    Ok(())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="session-example"><a class="header" href="#session-example">Session Example</a></h1>
<p>The <a href="https://github.com/tag1consulting/goose/blob/main/examples/session.rs"><code>examples/session.rs</code></a> example demonstrates how you can add JWT authentication support to your load test, making use of the <a href="https://docs.rs/goose/*/goose/goose/trait.GooseUserData.html"><code>GooseUserData</code></a> marker trait. In this example, the session is recorded in the <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> object with <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html#method.set_session_data"><code>set_session_data</code></a>, and retrieved with <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html#method.get_session_data_unchecked"><code>get_session_data_unchecked</code></a>.</p>
<h2 id="details-2"><a class="header" href="#details-2">Details</a></h2>
<p>In this example, the <a href="https://docs.rs/goose/*/goose/goose/trait.GooseUserData.html"><code>GooseUserData</code></a> is a simple struct containing a string:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Session {
    jwt_token: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>The session data structure is created from json-formatted response data returned by an authentication request, uniquely stored in each <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> instance:</p>
<pre><code class="language-rust ignore">    user.set_session_data(Session {
        jwt_token: response.jwt_token,
    });
</code></pre>
<p>The session data is retrieved from the <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> object with each subsequent request. To keep the example simple no validation is done:</p>
<pre><code class="language-rust ignore">    // This will panic if the session is missing or if the session is not of the right type.
    // Use `get_session_data` to handle a missing session.
    let session = user.get_session_data_unchecked::&lt;Session&gt;();

    // Create a Reqwest RequestBuilder object and configure bearer authentication when making
    // a GET request for the index.
    let reqwest_request_builder = user
        .get_request_builder(&amp;GooseMethod::Get, &quot;/&quot;)?
        .bearer_auth(&amp;session.jwt_token);
</code></pre>
<p><em>This example will panic if you run it without setting up a proper load test environment that actually sets the expected JWT token.</em></p>
<h2 id="complete-source-code-2"><a class="header" href="#complete-source-code-2">Complete Source Code</a></h2>
<pre><code class="language-rust ignore">//! Goose load test example, leveraging the per-GooseUser `GooseUserData` field to store
//! a per-user session JWT authentication token.
//!
//! ## License
//!
//! Copyright 2020 Jeremy Andrews
//!
//! Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//! you may not use this file except in compliance with the License.
//! You may obtain a copy of the License at
//!
//! http://www.apache.org/licenses/LICENSE-2.0
//!
//! Unless required by applicable law or agreed to in writing, software
//! distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//! See the License for the specific language governing permissions and
//! limitations under the License.

use goose::prelude::*;
use serde::Deserialize;
use std::time::Duration;

struct Session {
    jwt_token: String,
}

#[derive(Deserialize)]
#[serde(rename_all = &quot;camelCase&quot;)]
struct AuthenticationResponse {
    jwt_token: String,
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), GooseError&gt; {
    GooseAttack::initialize()?
        // In this example, we only create a single taskset, named &quot;WebsiteUser&quot;.
        .register_taskset(
            taskset!(&quot;WebsiteUser&quot;)
                // After each task runs, sleep randomly from 5 to 15 seconds.
                .set_wait_time(Duration::from_secs(5), Duration::from_secs(15))?
                // This task only runs one time when the user first starts.
                .register_task(task!(website_signup).set_on_start())
                // These next two tasks run repeatedly as long as the load test is running.
                .register_task(task!(authenticated_index)),
        )
        .execute()
        .await?
        .print();

    Ok(())
}

/// Demonstrates how to log in and set a session when a user starts. We flag this task as an
/// on_start task when registering it above. This means it only runs one time
/// per user, when the user thread first starts.
async fn website_signup(user: &amp;mut GooseUser) -&gt; GooseTaskResult {
    let params = [(&quot;username&quot;, &quot;test_user&quot;), (&quot;password&quot;, &quot;&quot;)];
    let response = user
        .post_form(&quot;/signup&quot;, &amp;params)
        .await?
        .response?
        .json::&lt;AuthenticationResponse&gt;()
        .await?;

    user.set_session_data(Session {
        jwt_token: response.jwt_token,
    });

    Ok(())
}

/// A very simple task that simply loads the front page.
async fn authenticated_index(user: &amp;mut GooseUser) -&gt; GooseTaskResult {
    // This will panic if the session is missing or if the session is not of the right type.
    // Use `get_session_data` to handle a missing session.
    let session = user.get_session_data_unchecked::&lt;Session&gt;();

    // Create a Reqwest RequestBuilder object and configure bearer authentication when making
    // a GET request for the index.
    let reqwest_request_builder = user
        .get_request_builder(&amp;GooseMethod::Get, &quot;/&quot;)?
        .bearer_auth(&amp;session.jwt_token);

    // Add the manually created RequestBuilder and build a GooseRequest object.
    let goose_request = GooseRequest::builder()
        .set_request_builder(reqwest_request_builder)
        .build();

    // Make the actual request.
    user.request(goose_request).await?;

    Ok(())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drupal-memcache-example"><a class="header" href="#drupal-memcache-example">Drupal Memcache Example</a></h1>
<p>The <a href="https://github.com/tag1consulting/goose/blob/main/examples/drupal_memcache.rs"><code>examples/drupal_memcache.rs</code></a> example is used to validate the performance of each release of the <a href="https://www.drupal.org/project/memcache">Drupal Memcache Module</a>.</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>Prior to every release of the <a href="https://www.drupal.org/project/memcache">Drupal Memcache Module</a>, <a href="https://www.tag1.com/">Tag1 Consulting</a> has run a load test to ensure consistent performance of the module which is dependend on by <a href="https://www.drupal.org/project/usage/memcache">tens of thousands of Drupal websites</a>.</p>
<p>The load test was initially implemented as a <a href="https://github.com/tag1consulting/drupal-loadtest/tree/206716d2bd3fdd199febba34a964117e1fd0fbde">JMeter testplan</a>. It was later converted to a <a href="https://github.com/tag1consulting/drupal-loadtest">Locust testplan</a>. Most recently it was converted to a <a href="https://github.com/tag1consulting/goose/blob/main/examples/drupal_memcache.rs">Goose testplan</a>.</p>
<p>Thie testplan is maintained as a simple real-world Goose load test example.</p>
<h2 id="details-3"><a class="header" href="#details-3">Details</a></h2>
<p>The authenticated <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> is labeled as <code>AuthBrowsingUser</code> and demonstrates logging in one time at the start of the load test:</p>
<pre><code class="language-rust ignore">            taskset!(&quot;AuthBrowsingUser&quot;)
                .set_weight(1)?
                .register_task(
                    task!(drupal_memcache_login)
                        .set_on_start()
                        .set_name(&quot;(Auth) login&quot;),
                )
</code></pre>
<p>Each <a href="https://docs.rs/goose/*/goose/goose/struct.GooseUser.html"><code>GooseUser</code></a> thread logs in as a random user (depending on a properly configured test environment):</p>
<pre><code class="language-rust ignore">                    // Log the user in.
                    let uid: usize = rand::thread_rng().gen_range(3..5_002);
                    let username = format!(&quot;user{}&quot;, uid);
                    let params = [
                        (&quot;name&quot;, username.as_str()),
                        (&quot;pass&quot;, &quot;12345&quot;),
                        (&quot;form_build_id&quot;, &amp;form_build_id[1]),
                        (&quot;form_id&quot;, &quot;user_login&quot;),
                        (&quot;op&quot;, &quot;Log+in&quot;),
                    ];
                    let _goose = user.post_form(&quot;/user&quot;, &amp;params).await?;
                    // @TODO: verify that we actually logged in.
</code></pre>
<p>The test also includes an example of how to post a comment during a load test:</p>
<pre><code class="language-rust ignore">                .register_task(
                    task!(drupal_memcache_post_comment)
                        .set_weight(3)?
                        .set_name(&quot;(Auth) comment form&quot;),
                ),
</code></pre>
<p>Note that much of this functionality can be simplified by using the <a href="https://docs.rs/goose-eggs">Goose Eggs library</a> which includes some <a href="https://docs.rs/goose-eggs/*/goose_eggs/drupal/index.html">Drupal-specific functionality</a>.</p>
<h2 id="complete-source-code-3"><a class="header" href="#complete-source-code-3">Complete Source Code</a></h2>
<pre><code class="language-rust ignore">//! Conversion of Locust load test used for the Drupal memcache module, from
//! https://github.com/tag1consulting/drupal-loadtest/
//!
//! To run, you must set up the load test environment as described in the above
//! repository, and then run the example. You'll need to set --host and may want
//! to set other command line options as well, starting with:
//!      cargo run --release --example drupal_memcache --
//!
//! ## License
//!
//! Copyright 2020 Jeremy Andrews
//!
//! Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//! you may not use this file except in compliance with the License.
//! You may obtain a copy of the License at
//!
//! http://www.apache.org/licenses/LICENSE-2.0
//!
//! Unless required by applicable law or agreed to in writing, software
//! distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//! See the License for the specific language governing permissions and
//! limitations under the License.

use goose::prelude::*;

use rand::Rng;
use regex::Regex;

#[tokio::main]
async fn main() -&gt; Result&lt;(), GooseError&gt; {
    GooseAttack::initialize()?
        .register_taskset(
            taskset!(&quot;AnonBrowsingUser&quot;)
                .set_weight(4)?
                .register_task(
                    task!(drupal_memcache_front_page)
                        .set_weight(15)?
                        .set_name(&quot;(Anon) front page&quot;),
                )
                .register_task(
                    task!(drupal_memcache_node_page)
                        .set_weight(10)?
                        .set_name(&quot;(Anon) node page&quot;),
                )
                .register_task(
                    task!(drupal_memcache_profile_page)
                        .set_weight(3)?
                        .set_name(&quot;(Anon) user page&quot;),
                ),
        )
        .register_taskset(
            taskset!(&quot;AuthBrowsingUser&quot;)
                .set_weight(1)?
                .register_task(
                    task!(drupal_memcache_login)
                        .set_on_start()
                        .set_name(&quot;(Auth) login&quot;),
                )
                .register_task(
                    task!(drupal_memcache_front_page)
                        .set_weight(15)?
                        .set_name(&quot;(Auth) front page&quot;),
                )
                .register_task(
                    task!(drupal_memcache_node_page)
                        .set_weight(10)?
                        .set_name(&quot;(Auth) node page&quot;),
                )
                .register_task(
                    task!(drupal_memcache_profile_page)
                        .set_weight(3)?
                        .set_name(&quot;(Auth) user page&quot;),
                )
                .register_task(
                    task!(drupal_memcache_post_comment)
                        .set_weight(3)?
                        .set_name(&quot;(Auth) comment form&quot;),
                ),
        )
        .execute()
        .await?
        .print();

    Ok(())
}

/// View the front page.
async fn drupal_memcache_front_page(user: &amp;mut GooseUser) -&gt; GooseTaskResult {
    let mut goose = user.get(&quot;/&quot;).await?;

    match goose.response {
        Ok(response) =&gt; {
            // Copy the headers so we have them for logging if there are errors.
            let headers = &amp;response.headers().clone();
            match response.text().await {
                Ok(t) =&gt; {
                    let re = Regex::new(r#&quot;src=&quot;(.*?)&quot;&quot;#).unwrap();
                    // Collect copy of URLs to run them async
                    let mut urls = Vec::new();
                    for url in re.captures_iter(&amp;t) {
                        if url[1].contains(&quot;/misc&quot;) || url[1].contains(&quot;/themes&quot;) {
                            urls.push(url[1].to_string());
                        }
                    }
                    for asset in &amp;urls {
                        let _ = user.get_named(asset, &quot;static asset&quot;).await;
                    }
                }
                Err(e) =&gt; {
                    // This will automatically get written to the error log if enabled, and will
                    // be displayed to stdout if `-v` is enabled when running the load test.
                    return user.set_failure(
                        &amp;format!(&quot;front_page: failed to parse page: {}&quot;, e),
                        &amp;mut goose.request,
                        Some(headers),
                        None,
                    );
                }
            }
        }
        Err(e) =&gt; {
            // This will automatically get written to the error log if enabled, and will
            // be displayed to stdout if `-v` is enabled when running the load test.
            return user.set_failure(
                &amp;format!(&quot;front_page: no response from server: {}&quot;, e),
                &amp;mut goose.request,
                None,
                None,
            );
        }
    }

    Ok(())
}

/// View a node from 1 to 10,000, created by preptest.sh.
async fn drupal_memcache_node_page(user: &amp;mut GooseUser) -&gt; GooseTaskResult {
    let nid = rand::thread_rng().gen_range(1..10_000);
    let _goose = user.get(format!(&quot;/node/{}&quot;, &amp;nid).as_str()).await?;

    Ok(())
}

/// View a profile from 2 to 5,001, created by preptest.sh.
async fn drupal_memcache_profile_page(user: &amp;mut GooseUser) -&gt; GooseTaskResult {
    let uid = rand::thread_rng().gen_range(2..5_001);
    let _goose = user.get(format!(&quot;/user/{}&quot;, &amp;uid).as_str()).await?;

    Ok(())
}

/// Log in.
async fn drupal_memcache_login(user: &amp;mut GooseUser) -&gt; GooseTaskResult {
    let mut goose = user.get(&quot;/user&quot;).await?;

    match goose.response {
        Ok(response) =&gt; {
            // Copy the headers so we have them for logging if there are errors.
            let headers = &amp;response.headers().clone();
            match response.text().await {
                Ok(html) =&gt; {
                    let re = Regex::new(r#&quot;name=&quot;form_build_id&quot; value=['&quot;](.*?)['&quot;]&quot;#).unwrap();
                    let form_build_id = match re.captures(&amp;html) {
                        Some(f) =&gt; f,
                        None =&gt; {
                            // This will automatically get written to the error log if enabled, and will
                            // be displayed to stdout if `-v` is enabled when running the load test.
                            return user.set_failure(
                                &quot;login: no form_build_id on page: /user page&quot;,
                                &amp;mut goose.request,
                                Some(headers),
                                Some(&amp;html),
                            );
                        }
                    };

                    // Log the user in.
                    let uid: usize = rand::thread_rng().gen_range(3..5_002);
                    let username = format!(&quot;user{}&quot;, uid);
                    let params = [
                        (&quot;name&quot;, username.as_str()),
                        (&quot;pass&quot;, &quot;12345&quot;),
                        (&quot;form_build_id&quot;, &amp;form_build_id[1]),
                        (&quot;form_id&quot;, &quot;user_login&quot;),
                        (&quot;op&quot;, &quot;Log+in&quot;),
                    ];
                    let _goose = user.post_form(&quot;/user&quot;, &amp;params).await?;
                    // @TODO: verify that we actually logged in.
                }
                Err(e) =&gt; {
                    // This will automatically get written to the error log if enabled, and will
                    // be displayed to stdout if `-v` is enabled when running the load test.
                    return user.set_failure(
                        &amp;format!(&quot;login: unexpected error when loading /user page: {}&quot;, e),
                        &amp;mut goose.request,
                        Some(headers),
                        None,
                    );
                }
            }
        }
        // Goose will catch this error.
        Err(e) =&gt; {
            // This will automatically get written to the error log if enabled, and will
            // be displayed to stdout if `-v` is enabled when running the load test.
            return user.set_failure(
                &amp;format!(&quot;login: no response from server: {}&quot;, e),
                &amp;mut goose.request,
                None,
                None,
            );
        }
    }

    Ok(())
}

/// Post a comment.
async fn drupal_memcache_post_comment(user: &amp;mut GooseUser) -&gt; GooseTaskResult {
    let nid: i32 = rand::thread_rng().gen_range(1..10_000);
    let node_path = format!(&quot;node/{}&quot;, &amp;nid);
    let comment_path = format!(&quot;/comment/reply/{}&quot;, &amp;nid);

    let mut goose = user.get(&amp;node_path).await?;

    match goose.response {
        Ok(response) =&gt; {
            // Copy the headers so we have them for logging if there are errors.
            let headers = &amp;response.headers().clone();
            match response.text().await {
                Ok(html) =&gt; {
                    // Extract the form_build_id from the user login form.
                    let re = Regex::new(r#&quot;name=&quot;form_build_id&quot; value=['&quot;](.*?)['&quot;]&quot;#).unwrap();
                    let form_build_id = match re.captures(&amp;html) {
                        Some(f) =&gt; f,
                        None =&gt; {
                            // This will automatically get written to the error log if enabled, and will
                            // be displayed to stdout if `-v` is enabled when running the load test.
                            return user.set_failure(
                                &amp;format!(&quot;post_comment: no form_build_id found on {}&quot;, &amp;node_path),
                                &amp;mut goose.request,
                                Some(headers),
                                Some(&amp;html),
                            );
                        }
                    };

                    let re = Regex::new(r#&quot;name=&quot;form_token&quot; value=['&quot;](.*?)['&quot;]&quot;#).unwrap();
                    let form_token = match re.captures(&amp;html) {
                        Some(f) =&gt; f,
                        None =&gt; {
                            // This will automatically get written to the error log if enabled, and will
                            // be displayed to stdout if `-v` is enabled when running the load test.
                            return user.set_failure(
                                &amp;format!(&quot;post_comment: no form_token found on {}&quot;, &amp;node_path),
                                &amp;mut goose.request,
                                Some(headers),
                                Some(&amp;html),
                            );
                        }
                    };

                    let re = Regex::new(r#&quot;name=&quot;form_id&quot; value=['&quot;](.*?)['&quot;]&quot;#).unwrap();
                    let form_id = match re.captures(&amp;html) {
                        Some(f) =&gt; f,
                        None =&gt; {
                            // This will automatically get written to the error log if enabled, and will
                            // be displayed to stdout if `-v` is enabled when running the load test.
                            return user.set_failure(
                                &amp;format!(&quot;post_comment: no form_id found on {}&quot;, &amp;node_path),
                                &amp;mut goose.request,
                                Some(headers),
                                Some(&amp;html),
                            );
                        }
                    };
                    // Optionally uncomment to log form_id, form_build_id, and form_token, together with
                    // the full body of the page. This is useful when modifying the load test.
                    /*
                    user.log_debug(
                        &amp;format!(
                            &quot;form_id: {}, form_build_id: {}, form_token: {}&quot;,
                            &amp;form_id[1], &amp;form_build_id[1], &amp;form_token[1]
                        ),
                        Some(&amp;goose.request),
                        Some(headers),
                        Some(&amp;html),
                    );
                    */

                    let comment_body = &quot;this is a test comment body&quot;;
                    let params = [
                        (&quot;subject&quot;, &quot;this is a test comment subject&quot;),
                        (&quot;comment_body[und][0][value]&quot;, comment_body),
                        (&quot;comment_body[und][0][format]&quot;, &quot;filtered_html&quot;),
                        (&quot;form_build_id&quot;, &amp;form_build_id[1]),
                        (&quot;form_token&quot;, &amp;form_token[1]),
                        (&quot;form_id&quot;, &amp;form_id[1]),
                        (&quot;op&quot;, &quot;Save&quot;),
                    ];

                    // Post the comment.
                    let mut goose = user.post_form(&amp;comment_path, &amp;params).await?;

                    // Verify that the comment posted.
                    match goose.response {
                        Ok(response) =&gt; {
                            // Copy the headers so we have them for logging if there are errors.
                            let headers = &amp;response.headers().clone();
                            match response.text().await {
                                Ok(html) =&gt; {
                                    if !html.contains(&amp;comment_body) {
                                        // This will automatically get written to the error log if enabled, and will
                                        // be displayed to stdout if `-v` is enabled when running the load test.
                                        return user.set_failure(
                                            &amp;format!(&quot;post_comment: no comment showed up after posting to {}&quot;, &amp;comment_path),
                                            &amp;mut goose.request,
                                            Some(headers),
                                            Some(&amp;html),
                                        );
                                    }
                                }
                                Err(e) =&gt; {
                                    // This will automatically get written to the error log if enabled, and will
                                    // be displayed to stdout if `-v` is enabled when running the load test.
                                    return user.set_failure(
                                        &amp;format!(
                                            &quot;post_comment: unexpected error when posting to {}: {}&quot;,
                                            &amp;comment_path, e
                                        ),
                                        &amp;mut goose.request,
                                        Some(headers),
                                        None,
                                    );
                                }
                            }
                        }
                        Err(e) =&gt; {
                            // This will automatically get written to the error log if enabled, and will
                            // be displayed to stdout if `-v` is enabled when running the load test.
                            return user.set_failure(
                                &amp;format!(
                                    &quot;post_comment: no response when posting to {}: {}&quot;,
                                    &amp;comment_path, e
                                ),
                                &amp;mut goose.request,
                                None,
                                None,
                            );
                        }
                    }
                }
                Err(e) =&gt; {
                    // This will automatically get written to the error log if enabled, and will
                    // be displayed to stdout if `-v` is enabled when running the load test.
                    return user.set_failure(
                        &amp;format!(&quot;post_comment: no text when loading {}: {}&quot;, &amp;node_path, e),
                        &amp;mut goose.request,
                        None,
                        None,
                    );
                }
            }
        }
        Err(e) =&gt; {
            // This will automatically get written to the error log if enabled, and will
            // be displayed to stdout if `-v` is enabled when running the load test.
            return user.set_failure(
                &amp;format!(
                    &quot;post_comment: no response when loading {}: {}&quot;,
                    &amp;node_path, e
                ),
                &amp;mut goose.request,
                None,
                None,
            );
        }
    }

    Ok(())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="umami-example"><a class="header" href="#umami-example">Umami Example</a></h1>
<p>The <a href="https://github.com/tag1consulting/goose/tree/main/examples/umami"><code>examples/umami</code></a> example load tests the <a href="https://www.drupal.org/docs/umami-drupal-demonstration-installation-profile">Umami demonstration profile</a> included with <a href="https://www.drupal.org/blog/drupal-9-released">Drupal 9</a>.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The Drupal Umami demonstration profile generates an attractive and realistic website simulating a food magazine, offering a practical example of what Drupal is capable of. The demo site is multi-lingual and has quite a bit of content, multiple taxonomies, and much of the rich functionality you'd expect from a real website, making it a good load test target.</p>
<p>The included example simulates three different types of users: an anonymous user browsing the site in English, an anonymous user browsing the site in Spanish, and an administrative user that logs into the site. The two anonymous users visit every page on the site. For example, the anonymous user browsing the site in English loads the front page, browses all the articles and the article listings, views all the recipes and recipe listings, accesses all nodes directly by node id, performs searches using terms pulled from actual site content, and fills out the site's contact form. With each action performed, Goose validates the HTTP response code and inspects the HTML returned to confirm that it contains the elements we expect.</p>
<p>Read the blog <a href="https://www.tag1consulting.com/blog/goose-clouds-load-testing-scale">A Goose In The Clouds: Load Testing At Scale</a> for a demonstration of using this example, and learn more about the testplan from the <a href="https://github.com/tag1consulting/goose/blob/main/examples/umami/README.md">README</a>.</p>
<h2 id="alternative"><a class="header" href="#alternative">Alternative</a></h2>
<p>The <a href="https://docs.rs/goose-eggs/">Goose Eggs library</a> contains <a href="https://github.com/tag1consulting/goose-eggs/tree/main/examples/umami">a variation of the Umami example</a>.</p>
<h2 id="complete-source-code-4"><a class="header" href="#complete-source-code-4">Complete Source Code</a></h2>
<p>This example is more complex than the other examples, and is split into multiple files, all of which can be found within <a href="https://github.com/tag1consulting/goose/tree/main/examples/umami"><code>examples/umami</code></a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
